var searchIndex={};
searchIndex["argmin"] = {"doc":"A pure Rust optimization framework","i":[[0,"core","argmin","Core functionality Argmin Optimizaton toolbox core",null,null],[3,"Error","argmin::core","The `Error` type, a wrapper around a dynamic error type.",null,null],[3,"IterState","","Maintains the state from iteration to iteration of a solver",null,null],[12,"param","","Current parameter vector",0,null],[12,"prev_param","","Previous parameter vector",0,null],[12,"best_param","","Current best parameter vector",0,null],[12,"prev_best_param","","Previous best parameter vector",0,null],[12,"cost","","Current cost function value",0,null],[12,"prev_cost","","Previous cost function value",0,null],[12,"best_cost","","Current best cost function value",0,null],[12,"prev_best_cost","","Previous best cost function value",0,null],[12,"target_cost","","Target cost function value",0,null],[12,"grad","","Current gradient",0,null],[12,"prev_grad","","Previous gradient",0,null],[12,"hessian","","Current Hessian",0,null],[12,"prev_hessian","","Previous Hessian",0,null],[12,"jacobian","","Current Jacobian",0,null],[12,"prev_jacobian","","Previous Jacobian",0,null],[12,"population","","All members for population-based algorithms as (param,…",0,null],[12,"iter","","Current iteration",0,null],[12,"last_best_iter","","Iteration number of last best cost",0,null],[12,"max_iters","","Maximum number of iterations",0,null],[12,"cost_func_count","","Number of cost function evaluations so far",0,null],[12,"grad_func_count","","Number of gradient evaluations so far",0,null],[12,"hessian_func_count","","Number of Hessian evaluations so far",0,null],[12,"jacobian_func_count","","Number of Jacobian evaluations so far",0,null],[12,"modify_func_count","","Number of modify evaluations so far",0,null],[12,"time","","Time required so far",0,null],[12,"termination_reason","","Reason of termination",0,null],[3,"ArgminKV","","A simple key-value storage",null,null],[12,"kv","","The actual key value storage",1,null],[3,"NoOperator","","Fake Operators for testing No-op operator with free choice…",null,null],[3,"MinimalNoOperator","","Minimal No-op operator which does nothing, really.",null,null],[3,"WriteToFile","","Write parameter vectors to file",null,null],[3,"ArgminSlogLogger","","A logger based on `slog`",null,null],[3,"ArgminSlogKV","","This type is necessary in order to be able to implement…",null,null],[12,"kv","","Key value store",2,null],[3,"Visualizer3d","","Visualize iterations of a solver for cost functions of…",null,null],[3,"Surface","","Helper class for visualized surface",null,null],[3,"Observer","","Container for observers which acts just like a single…",null,null],[3,"OpWrapper","","This wraps an operator and keeps track of how often the…",null,null],[12,"op","","Operator",3,null],[12,"cost_func_count","","Number of cost function evaluations",3,null],[12,"grad_func_count","","Number of gradient function evaluations",3,null],[12,"hessian_func_count","","Number of Hessian function evaluations",3,null],[12,"jacobian_func_count","","Number of Jacobian function evaluations",3,null],[12,"modify_func_count","","Number of `modify` function evaluations",3,null],[3,"ArgminResult","","Final struct returned by the `run` method of `Executor`.",null,null],[12,"operator","","operator",4,null],[12,"state","","iteration state",4,null],[3,"ArgminCheckpoint","","Checkpoint",null,null],[3,"ArgminIterData","","The datastructure which is returned by the `next_iter`…",null,null],[4,"ArgminError","","Argmin error type",null,null],[13,"InvalidParameter","","Indicates and invalid parameter",5,null],[12,"text","argmin::core::ArgminError","Text",6,null],[13,"NotImplemented","argmin::core","Indicates that a function is not implemented",5,null],[12,"text","argmin::core::ArgminError","Text",7,null],[13,"NotInitialized","argmin::core","Indicates that a function is not initialized",5,null],[12,"text","argmin::core::ArgminError","Text",8,null],[13,"ConditionViolated","argmin::core","Indicates that a condition is violated",5,null],[12,"text","argmin::core::ArgminError","Text",9,null],[13,"CheckpointNotFound","argmin::core","Checkpoint was not found",5,null],[12,"text","argmin::core::ArgminError","Text",10,null],[13,"ImpossibleError","argmin::core","Indicates an impossible error",5,null],[12,"text","argmin::core::ArgminError","Text",11,null],[4,"WriteToFileSerializer","argmin::core","Different kinds of serializers",null,null],[13,"Bincode","","Bincode",12,null],[13,"JSON","","JSON",12,null],[4,"ObserverMode","","This is used to indicate how often the observer will…",null,null],[13,"Never","","Never call the observer",13,null],[13,"Always","","Call observer in every iteration",13,null],[13,"Every","","Call observer every N iterations",13,null],[13,"NewBest","","Call observer when new best is found",13,null],[4,"CheckpointMode","","Defines at which intervals a checkpoint is saved.",null,null],[13,"Never","","Never create checkpoint",14,null],[13,"Every","","Create checkpoint every N iterations",14,null],[13,"Always","","Create checkpoint in every iteration",14,null],[4,"TerminationReason","","Indicates why the optimization algorithm stopped",null,null],[13,"NotTerminated","","In case it has not terminated yet",15,null],[13,"MaxItersReached","","Maximum number of iterations reached",15,null],[13,"TargetCostReached","","Target cost function value reached",15,null],[13,"TargetPrecisionReached","","Target precision reached",15,null],[13,"NoChangeInCost","","Cost function value did not change",15,null],[13,"AcceptedStallIterExceeded","","Acceped stall iter exceeded",15,null],[13,"BestStallIterExceeded","","Best stall iter exceeded",15,null],[13,"LineSearchConditionMet","","Condition for Line search met",15,null],[13,"TargetToleranceReached","","Target tolerance reached",15,null],[13,"Aborted","","Aborted",15,null],[5,"load_checkpoint","","Load a checkpoint from disk",null,[[["path"],["asref",["path"]]],[["error"],["result",["error"]],["deserializeowned"]]]],[0,"macros","","Macros # Macros",null,null],[0,"executor","","Executor",null,null],[3,"Executor","argmin::core::executor","Executes a solver",null,null],[12,"op","","operator",16,null],[11,"new","","Create a new executor with a `solver` and an initial…",16,[[["o"],["s"]],["self"]]],[11,"from_checkpoint","","Create a new executor from a checkpoint",16,[[["path"],["o"],["asref",["path"]]],[["result",["error"]],["error"]]]],[11,"run","","Run the executor",16,[[],[["result",["argminresult","error"]],["argminresult"],["error"]]]],[11,"add_observer","","Attaches a observer which implements `ArgminLog` to the…",16,[[["observe"],["observermode"]],["self"]]],[11,"max_iters","","Set maximum number of iterations",16,[[["u64"]],["self"]]],[11,"target_cost","","Set target cost value",16,[[],["self"]]],[11,"cost","","Set cost value",16,[[],["self"]]],[11,"grad","","Set Gradient",16,[[],["self"]]],[11,"hessian","","Set Hessian",16,[[],["self"]]],[11,"jacobian","","Set Jacobian",16,[[],["self"]]],[11,"checkpoint_dir","","Set checkpoint directory",16,[[["str"]],["self"]]],[11,"checkpoint_name","","Set checkpoint name",16,[[["str"]],["self"]]],[11,"checkpoint_mode","","Set the checkpoint mode",16,[[["checkpointmode"]],["self"]]],[11,"ctrlc","","Turn Ctrl-C handling on or off (default: on)",16,[[["bool"]],["self"]]],[11,"new","argmin::core","Create new IterState from `param`",0,[[],["self"]]],[11,"param","","Set parameter vector. This shifts the stored parameter…",0,[[["self"]],["self"]]],[11,"best_param","","Set best paramater vector. This shifts the stored best…",0,[[["self"]],["self"]]],[11,"cost","","Set the current cost function value. This shifts the…",0,[[["self"]],["self"]]],[11,"best_cost","","Set the current best cost function value. This shifts the…",0,[[["self"]],["self"]]],[11,"grad","","Set gradient. This shifts the stored gradient to the…",0,[[["self"]],["self"]]],[11,"hessian","","Set Hessian. This shifts the stored Hessian to the…",0,[[["self"]],["self"]]],[11,"jacobian","","Set Jacobian. This shifts the stored Jacobian to the…",0,[[["self"]],["self"]]],[11,"population","","Set population",0,[[["self"],["vec"]],["self"]]],[11,"target_cost","","Set target cost value",0,[[["self"]],["self"]]],[11,"max_iters","","Set maximum number of iterations",0,[[["self"],["u64"]],["self"]]],[11,"last_best_iter","","Set iteration number where the previous best parameter…",0,[[["self"],["u64"]],["self"]]],[11,"termination_reason","","Set termination_reason",0,[[["self"],["terminationreason"]],["self"]]],[11,"time","","Set time required so far",0,[[["self"],["duration"]],["self"]]],[11,"get_param","","Returns current parameter vector",0,[[["self"]]]],[11,"get_prev_param","","Returns previous parameter vector",0,[[["self"]]]],[11,"get_best_param","","Returns best parameter vector",0,[[["self"]]]],[11,"get_prev_best_param","","Returns previous best parameter vector",0,[[["self"]]]],[11,"get_cost","","Returns current cost function value",0,[[["self"]]]],[11,"get_prev_cost","","Returns previous cost function value",0,[[["self"]]]],[11,"get_best_cost","","Returns current best cost function value",0,[[["self"]]]],[11,"get_prev_best_cost","","Returns previous best cost function value",0,[[["self"]]]],[11,"get_target_cost","","Returns target cost",0,[[["self"]]]],[11,"get_cost_func_count","","Returns current cost function evaluation count",0,[[["self"]],["u64"]]],[11,"get_grad_func_count","","Returns current gradient function evaluation count",0,[[["self"]],["u64"]]],[11,"get_hessian_func_count","","Returns current Hessian function evaluation count",0,[[["self"]],["u64"]]],[11,"get_jacobian_func_count","","Returns current Jacobian function evaluation count",0,[[["self"]],["u64"]]],[11,"get_modify_func_count","","Returns current Modify function evaluation count",0,[[["self"]],["u64"]]],[11,"get_last_best_iter","","Returns iteration number where the last best parameter…",0,[[["self"]],["u64"]]],[11,"get_termination_reason","","Get termination_reason",0,[[["self"]],["terminationreason"]]],[11,"get_time","","Get time required so far",0,[[["self"]],["duration"]]],[11,"get_grad","","Returns gradient",0,[[["self"]],["option"]]],[11,"get_prev_grad","","Returns previous gradient",0,[[["self"]],["option"]]],[11,"get_hessian","","Returns current Hessian",0,[[["self"]],["option"]]],[11,"get_prev_hessian","","Returns previous Hessian",0,[[["self"]],["option"]]],[11,"get_jacobian","","Returns current Jacobian",0,[[["self"]],["option"]]],[11,"get_prev_jacobian","","Returns previous Jacobian",0,[[["self"]],["option"]]],[11,"get_iter","","Returns current number of iterations",0,[[["self"]],["u64"]]],[11,"get_max_iters","","Returns maximum number of iterations",0,[[["self"]],["u64"]]],[11,"get_population","","Returns population",0,[[["self"]],[["vec"],["option",["vec"]]]]],[11,"increment_iter","","Increment the number of iterations by one",0,[[["self"]]]],[11,"increment_func_counts","","Increment all function evaluation counts by the evaluation…",0,[[["self"],["opwrapper"]]]],[11,"set_func_counts","","Set all function evaluation counts to the evaluation…",0,[[["self"],["opwrapper"]]]],[11,"increment_cost_func_count","","Increment cost function evaluation count by `num`",0,[[["self"],["u64"]]]],[11,"increment_grad_func_count","","Increment gradient function evaluation count by `num`",0,[[["self"],["u64"]]]],[11,"increment_hessian_func_count","","Increment Hessian function evaluation count by `num`",0,[[["self"],["u64"]]]],[11,"increment_jacobian_func_count","","Increment Jacobian function evaluation count by `num`",0,[[["self"],["u64"]]]],[11,"increment_modify_func_count","","Increment modify function evaluation count by `num`",0,[[["self"],["u64"]]]],[11,"new_best","","Indicate that a new best parameter vector was found",0,[[["self"]]]],[11,"is_best","","Returns whether the current parameter vector is also the…",0,[[["self"]],["bool"]]],[11,"terminated","","Return whether the algorithm has terminated or not",0,[[["self"]],["bool"]]],[11,"new","","Constructor",1,[[],["self"]]],[11,"push","","Push a key-value pair to the `kv` vector.",1,[[["self"],["str"],["display"]],["self"]]],[11,"merge","","Merge another `kv` into `self.kv`",1,[[["argminkv"]],["self"]]],[11,"new","","Constructor",17,[[],["self"]]],[11,"new","","Constructor",18,[[],["self"]]],[11,"new","","Create a new `WriteToFile` struct",19,[[["str"]],["self"]]],[11,"serializer","","Set serializer",19,[[["writetofileserializer"]],["self"]]],[11,"term","","Log to the terminal in a blocking way",20,[[],["self"]]],[11,"term_noblock","","Log to the terminal in a non-blocking way (in case of…",20,[[],["self"]]],[11,"file","","Log JSON to a file in a blocking way",20,[[["str"],["bool"]],[["result",["error"]],["error"]]]],[11,"file_noblock","","Log JSON to a file in a non-blocking way (in case of…",20,[[["str"],["bool"]],[["result",["error"]],["error"]]]],[11,"new","","Create a new visualizer",21,[[],["self"]]],[11,"delay","","Set delay",21,[[["duration"]],["self"]]],[11,"surface","","Set surface",21,[[["surface"]],["self"]]],[11,"new","","Create a new surface",22,[[["o"],["f64"]],["self"]]],[11,"new","","Constructor",23,[[],["self"]]],[11,"push","","Push another `Observe` to the `observer` field",23,[[["observe"],["self"],["observermode"]],["self"]]],[11,"new","","Constructor",3,[[["o"]],["self"]]],[11,"new_from_wrapper","","Construct struct from other `OpWrapper`. Takes the…",3,[[["opwrapper"]],["self"]]],[11,"apply","","Calls the `apply` method of `op` and increments…",3,[[["self"]],[["result",["error"]],["error"]]]],[11,"gradient","","Calls the `gradient` method of `op` and increments…",3,[[["self"]],[["result",["error"]],["error"]]]],[11,"hessian","","Calls the `hessian` method of `op` and increments…",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"jacobian","","Calls the `jacobian` method of `op` and increments…",3,[[["self"]],[["result",["error"]],["error"]]]],[11,"modify","","Calls the `modify` method of `op` and increments…",3,[[["self"]],[["result",["error"]],["error"]]]],[11,"take_op","","Moves the operator out of the struct and replaces it with…",3,[[["self"]],["option"]]],[11,"consume_op","","Consumes an operator by increasing the function call…",3,[[["self"],["opwrapper"]]]],[11,"consume_func_counts","","Adds function evaluation counts of another operator.",3,[[["self"],["opwrapper"],["argminop"]]]],[11,"reset","","Reset the cost function counts to zero.",3,[[],["self"]]],[11,"get_op","","Returns the operator `op` by taking ownership of `self`.",3,[[],["o"]]],[11,"new","","Constructor",4,[[["o"],["iterstate"]],["self"]]],[11,"operator","","Return handle to operator",4,[[["self"]],["o"]]],[11,"state","","Return handle to state",4,[[["self"]],["iterstate"]]],[11,"new","","Define a new checkpoint",24,[[["str"],["checkpointmode"]],[["result",["error"]],["error"]]]],[11,"set_dir","","Set directory of checkpoint",24,[[["str"],["self"]]]],[11,"dir","","Get directory of checkpoint",24,[[["self"]],["string"]]],[11,"set_name","","Set name of checkpoint",24,[[["str"],["self"]]]],[11,"name","","Get name of checkpoint",24,[[["self"]],["string"]]],[11,"set_mode","","Set mode of checkpoint",24,[[["self"],["checkpointmode"]]]],[11,"store","","Write checkpoint to disk",24,[[["t"],["self"],["string"]],[["result",["error"]],["error"]]]],[11,"store_cond","","Write checkpoint based on the desired `CheckpointMode`",24,[[["t"],["self"],["u64"]],[["result",["error"]],["error"]]]],[11,"terminated","","Returns `true` if a solver terminated and `false` otherwise",15,[[],["bool"]]],[11,"text","","Returns a texual representation of what happened",15,[[["self"]],["str"]]],[0,"file","","Output parameter vectors to file",null,null],[3,"WriteToFile","argmin::core::file","Write parameter vectors to file",null,null],[4,"WriteToFileSerializer","","Different kinds of serializers",null,null],[13,"Bincode","","Bincode",12,null],[13,"JSON","","JSON",12,null],[0,"slog_logger","argmin::core","Loggers based on the `slog` crate",null,null],[3,"ArgminSlogLogger","argmin::core::slog_logger","A logger based on `slog`",null,null],[3,"ArgminSlogKV","","This type is necessary in order to be able to implement…",null,null],[12,"kv","","Key value store",2,null],[0,"visualizer","argmin::core","Observer which visualizes the progress of the solver",null,null],[3,"Visualizer3d","argmin::core::visualizer","Visualize iterations of a solver for cost functions of…",null,null],[3,"Surface","","Helper class for visualized surface",null,null],[8,"ArgminDot","argmin::core","Dot/scalar product of `T` and `self`",null,null],[10,"dot","","Dot/scalar product of `T` and `self`",25,[[["t"],["self"]],["u"]]],[8,"ArgminWeightedDot","","Dot/scalar product of `T` and `self` weighted by W (p^TWv)",null,null],[10,"weighted_dot","","Dot/scalar product of `T` and `self`",26,[[["v"],["self"],["t"]],["u"]]],[8,"ArgminZero","","Return param vector of all zeros (for now, this is a hack.…",null,null],[10,"zero","","Return zero(s)",27,[[],["self"]]],[8,"ArgminConj","","Return the conjugate",null,null],[10,"conj","","Return conjugate",28,[[["self"]],["self"]]],[8,"ArgminZeroLike","","Zero for dynamically sized objects",null,null],[10,"zero_like","","Return zero(s)",29,[[["self"]],["self"]]],[8,"ArgminEye","","Identity matrix",null,null],[10,"eye","","Identity matrix of size `n`",30,[[["usize"]],["self"]]],[10,"eye_like","","Identity matrix of same size as `self`",30,[[["self"]],["self"]]],[8,"ArgminAdd","","Add a `T` to `self`",null,null],[10,"add","","Add a `T` to `self`",31,[[["t"],["self"]],["u"]]],[8,"ArgminSub","","Subtract a `T` from `self`",null,null],[10,"sub","","Subtract a `T` from `self`",32,[[["t"],["self"]],["u"]]],[8,"ArgminMul","","(Pointwise) Multiply a `T` with `self`",null,null],[10,"mul","","(Pointwise) Multiply a `T` with `self`",33,[[["t"],["self"]],["u"]]],[8,"ArgminDiv","","(Pointwise) Divide a `T` by `self`",null,null],[10,"div","","(Pointwise) Divide a `T` by `self`",34,[[["t"],["self"]],["u"]]],[8,"ArgminScaledAdd","","Add a `T` scaled by an `U` to `self`",null,null],[10,"scaled_add","","Add a `T` scaled by an `U` to `self`",35,[[["t"],["self"],["u"]],["v"]]],[8,"ArgminScaledSub","","Subtract a `T` scaled by an `U` from `self`",null,null],[10,"scaled_sub","","Subtract a `T` scaled by an `U` from `self`",36,[[["t"],["self"],["u"]],["v"]]],[8,"ArgminNorm","","Compute the l2-norm (`U`) of `self`",null,null],[10,"norm","","Compute the l2-norm (`U`) of `self`",37,[[["self"]],["u"]]],[8,"ArgminTranspose","","Transposing a type",null,null],[10,"t","","Transpose",38,[[],["self"]]],[8,"ArgminInv","","Compute the inverse (`T`) of `self`",null,null],[10,"inv","","Compute the inverse",39,[[["self"]],[["result",["error"]],["error"]]]],[8,"ArgminRandom","","Create a random number",null,null],[10,"rand_from_range","","Get a random element between min and max,",40,[[["self"]],["self"]]],[8,"ArgminMinMax","","Minimum and Maximum of type `T`",null,null],[10,"min","","Select piecewise minimum",41,[[["self"]],["self"]]],[10,"max","","Select piecewise maximum",41,[[["self"]],["self"]]],[8,"Observe","","Defines the interface every Observer needs to expose",null,null],[11,"observe_init","","Called once at the beginning of the execution of the solver.",42,[[["str"],["argminkv"],["self"]],[["result",["error"]],["error"]]]],[11,"observe_iter","","Called at every iteration of the solver",42,[[["argminkv"],["self"],["iterstate"]],[["result",["error"]],["error"]]]],[8,"ArgminFloat","","Trait alias to simplify common trait bounds",null,null],[8,"ArgminOp","","This trait needs to be implemented for every operator/cost…",null,null],[16,"Param","","Type of the parameter vector",43,null],[16,"Output","","Output of the operator",43,null],[16,"Hessian","","Type of Hessian",43,null],[16,"Jacobian","","Type of Jacobian",43,null],[16,"Float","","Precision of floats",43,null],[11,"apply","","Applies the operator/cost function to parameters",43,[[["self"]],[["error"],["result",["error"]]]]],[11,"gradient","","Computes the gradient at the given parameters",43,[[["self"]],[["error"],["result",["error"]]]]],[11,"hessian","","Computes the Hessian at the given parameters",43,[[["self"]],[["result",["error"]],["error"]]]],[11,"jacobian","","Computes the Hessian at the given parameters",43,[[["self"]],[["result",["error"]],["error"]]]],[11,"modify","","Modifies a parameter vector. Comes with a variable that…",43,[[["self"]],[["error"],["result",["error"]]]]],[8,"Solver","","Solver",null,null],[18,"NAME","","Name of the solver",44,null],[10,"next_iter","","Computes one iteration of the algorithm.",44,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"init","","Initializes the algorithm",44,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"terminate_internal","","Checks whether basic termination reasons apply.",44,[[["self"],["iterstate"]],["terminationreason"]]],[11,"terminate","","Checks whether the algorithm must be terminated",44,[[["self"],["iterstate"]],["terminationreason"]]],[8,"ArgminLineSearch","","Defines a common interface for line search methods.",null,null],[10,"set_search_direction","","Set the search direction",45,[[["self"],["p"]]]],[10,"set_init_alpha","","Set the initial step length",45,[[["self"],["f"]],[["result",["error"]],["error"]]]],[8,"ArgminTrustRegion","","Defines a common interface to methods which calculate…",null,null],[10,"set_radius","","Set the initial step length",46,[[["self"],["f"]]]],[8,"ArgminNLCGBetaUpdate","","Common interface for beta update methods (Nonlinear-CG)",null,null],[10,"update","","Update beta Parameter 1: \\nabla f_k Parameter 2: \\nabla…",47,[[["t"],["self"]],["f"]]],[11,"new","","Constructor",48,[[],["self"]]],[11,"param","","Set parameter vector",48,[[],["self"]]],[11,"cost","","Set cost function value",48,[[],["self"]]],[11,"grad","","Set gradient",48,[[],["self"]]],[11,"hessian","","Set Hessian",48,[[],["self"]]],[11,"jacobian","","Set Jacobian",48,[[],["self"]]],[11,"population","","Set Population",48,[[["vec"]],["self"]]],[11,"kv","","Adds an `ArgminKV`",48,[[["argminkv"]],["self"]]],[11,"termination_reason","","Set termination reason",48,[[["terminationreason"]],["self"]]],[11,"get_param","","Get parameter vector",48,[[["self"]],["option"]]],[11,"get_cost","","Get cost function value",48,[[["self"]],["option"]]],[11,"get_grad","","Get gradient",48,[[["self"]],["option"]]],[11,"get_hessian","","Get Hessian",48,[[["self"]],["option"]]],[11,"get_jacobian","","Get Jacobian",48,[[["self"]],["option"]]],[11,"get_population","","Get reference to population",48,[[["self"]],[["vec"],["option",["vec"]]]]],[11,"get_termination_reason","","Get termination reason",48,[[["self"]],[["option",["terminationreason"]],["terminationreason"]]]],[11,"get_kv","","Return KV",48,[[["self"]],["argminkv"]]],[0,"prelude","argmin","Definition of all relevant traits and types # Re-export of…",null,null],[0,"bounds","argmin::prelude","",null,null],[8,"Bounded","argmin::prelude::bounds","Numbers which have upper and lower bounds",null,null],[10,"min_value","","returns the smallest finite number this type can represent",49,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",49,[[],["self"]]],[0,"cast","argmin::prelude","",null,null],[8,"ToPrimitive","argmin::prelude::cast","A generic trait for converting a value to a number.",null,null],[11,"to_isize","","Converts the value of `self` to an `isize`. If the value…",50,[[["self"]],[["option",["isize"]],["isize"]]]],[11,"to_i8","","Converts the value of `self` to an `i8`. If the value…",50,[[["self"]],[["option",["i8"]],["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`. If the value…",50,[[["self"]],[["option",["i16"]],["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`. If the value…",50,[[["self"]],[["option",["i32"]],["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`. If the value…",50,[[["self"]],[["i64"],["option",["i64"]]]]],[11,"to_i128","","Converts the value of `self` to an `i128`. If the value…",50,[[["self"]],[["i128"],["option",["i128"]]]]],[11,"to_usize","","Converts the value of `self` to a `usize`. If the value…",50,[[["self"]],[["option",["usize"]],["usize"]]]],[11,"to_u8","","Converts the value of `self` to a `u8`. If the value…",50,[[["self"]],[["u8"],["option",["u8"]]]]],[11,"to_u16","","Converts the value of `self` to a `u16`. If the value…",50,[[["self"]],[["u16"],["option",["u16"]]]]],[11,"to_u32","","Converts the value of `self` to a `u32`. If the value…",50,[[["self"]],[["option",["u32"]],["u32"]]]],[10,"to_u64","","Converts the value of `self` to a `u64`. If the value…",50,[[["self"]],[["option",["u64"]],["u64"]]]],[11,"to_u128","","Converts the value of `self` to a `u128`. If the value…",50,[[["self"]],[["option",["u128"]],["u128"]]]],[11,"to_f32","","Converts the value of `self` to an `f32`. If the value…",50,[[["self"]],[["f32"],["option",["f32"]]]]],[11,"to_f64","","Converts the value of `self` to an `f64`. If the value…",50,[[["self"]],[["option",["f64"]],["f64"]]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Converts an `isize` to return an optional value of this…",51,[[["isize"]],["option"]]],[11,"from_i8","","Converts an `i8` to return an optional value of this type.…",51,[[["i8"]],["option"]]],[11,"from_i16","","Converts an `i16` to return an optional value of this…",51,[[["i16"]],["option"]]],[11,"from_i32","","Converts an `i32` to return an optional value of this…",51,[[["i32"]],["option"]]],[10,"from_i64","","Converts an `i64` to return an optional value of this…",51,[[["i64"]],["option"]]],[11,"from_i128","","Converts an `i128` to return an optional value of this…",51,[[["i128"]],["option"]]],[11,"from_usize","","Converts a `usize` to return an optional value of this…",51,[[["usize"]],["option"]]],[11,"from_u8","","Converts an `u8` to return an optional value of this type.…",51,[[["u8"]],["option"]]],[11,"from_u16","","Converts an `u16` to return an optional value of this…",51,[[["u16"]],["option"]]],[11,"from_u32","","Converts an `u32` to return an optional value of this…",51,[[["u32"]],["option"]]],[10,"from_u64","","Converts an `u64` to return an optional value of this…",51,[[["u64"]],["option"]]],[11,"from_u128","","Converts an `u128` to return an optional value of this…",51,[[["u128"]],["option"]]],[11,"from_f32","","Converts a `f32` to return an optional value of this type.…",51,[[["f32"]],["option"]]],[11,"from_f64","","Converts a `f64` to return an optional value of this type.…",51,[[["f64"]],["option"]]],[5,"cast","","Cast from one machine scalar to another.",null,[[["t"]],["option"]]],[8,"NumCast","","An interface for casting between machine scalars.",null,null],[10,"from","","Creates a number from another value that can be converted…",52,[[["t"]],["option"]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars…",null,null],[10,"as_","","Convert a value to another, using the `as` operator.",53,[[],["t"]]],[0,"float","argmin::prelude","",null,null],[8,"FloatCore","argmin::prelude::float","Generic trait for floating point numbers that works with…",null,null],[10,"infinity","","Returns positive infinity.",54,[[],["self"]]],[10,"neg_infinity","","Returns negative infinity.",54,[[],["self"]]],[10,"nan","","Returns NaN.",54,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",54,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can…",54,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",54,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",54,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",54,[[],["self"]]],[11,"is_nan","","Returns `true` if the number is NaN.",54,[[],["bool"]]],[11,"is_infinite","","Returns `true` if the number is infinite.",54,[[],["bool"]]],[11,"is_finite","","Returns `true` if the number is neither infinite or NaN.",54,[[],["bool"]]],[11,"is_normal","","Returns `true` if the number is neither zero, infinite,…",54,[[],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only…",54,[[],["fpcategory"]]],[11,"floor","","Returns the largest integer less than or equal to a number.",54,[[],["self"]]],[11,"ceil","","Returns the smallest integer greater than or equal to a…",54,[[],["self"]]],[11,"round","","Returns the nearest integer to a number. Round half-way…",54,[[],["self"]]],[11,"trunc","","Return the integer part of a number.",54,[[],["self"]]],[11,"fract","","Returns the fractional part of a number.",54,[[],["self"]]],[11,"abs","","Computes the absolute value of `self`. Returns…",54,[[],["self"]]],[11,"signum","","Returns a number that represents the sign of `self`.",54,[[],["self"]]],[11,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and…",54,[[],["bool"]]],[11,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and…",54,[[],["bool"]]],[11,"min","","Returns the minimum of the two numbers.",54,[[],["self"]]],[11,"max","","Returns the maximum of the two numbers.",54,[[],["self"]]],[11,"recip","","Returns the reciprocal (multiplicative inverse) of the…",54,[[],["self"]]],[11,"powi","","Raise a number to an integer power.",54,[[["i32"]],["self"]]],[10,"to_degrees","","Converts to degrees, assuming the number is in radians.",54,[[],["self"]]],[10,"to_radians","","Converts to radians, assuming the number is in degrees.",54,[[],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",54,[[]]],[8,"Float","","Generic trait for floating point numbers",null,null],[10,"nan","","Returns the `NaN` value.",55,[[],["self"]]],[10,"infinity","","Returns the infinite value.",55,[[],["self"]]],[10,"neg_infinity","","Returns the negative infinite value.",55,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",55,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can…",55,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",55,[[],["self"]]],[11,"epsilon","","Returns epsilon, a small positive value.",55,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",55,[[],["self"]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",55,[[],["bool"]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or…",55,[[],["bool"]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",55,[[],["bool"]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite,…",55,[[],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only…",55,[[],["fpcategory"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",55,[[],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a…",55,[[],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way…",55,[[],["self"]]],[10,"trunc","","Return the integer part of a number.",55,[[],["self"]]],[10,"fract","","Returns the fractional part of a number.",55,[[],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns…",55,[[],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",55,[[],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`,…",55,[[],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`,…",55,[[],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only…",55,[[],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",55,[[],["self"]]],[10,"powi","","Raise a number to an integer power.",55,[[["i32"]],["self"]]],[10,"powf","","Raise a number to a floating point power.",55,[[],["self"]]],[10,"sqrt","","Take the square root of a number.",55,[[],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",55,[[],["self"]]],[10,"exp2","","Returns `2^(self)`.",55,[[],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",55,[[],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an…",55,[[],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",55,[[],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",55,[[],["self"]]],[11,"to_degrees","","Converts radians to degrees.",55,[[],["self"]]],[11,"to_radians","","Converts degrees to radians.",55,[[],["self"]]],[10,"max","","Returns the maximum of the two numbers.",55,[[],["self"]]],[10,"min","","Returns the minimum of the two numbers.",55,[[],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",55,[[],["self"]]],[10,"cbrt","","Take the cubic root of a number.",55,[[],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle…",55,[[],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",55,[[],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",55,[[],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",55,[[],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in…",55,[[],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in…",55,[[],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in…",55,[[],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and…",55,[[],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number,…",55,[[]]],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if…",55,[[],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than…",55,[[],["self"]]],[10,"sinh","","Hyperbolic sine function.",55,[[],["self"]]],[10,"cosh","","Hyperbolic cosine function.",55,[[],["self"]]],[10,"tanh","","Hyperbolic tangent function.",55,[[],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",55,[[],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",55,[[],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",55,[[],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",55,[[]]],[8,"FloatConst","","",null,null],[10,"E","","Return Euler’s number.",56,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",56,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",56,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",56,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",56,[[],["self"]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",56,[[],["self"]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",56,[[],["self"]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",56,[[],["self"]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",56,[[],["self"]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",56,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",56,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",56,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",56,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",56,[[],["self"]]],[10,"PI","","Return Archimedes’ constant `π`.",56,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",56,[[],["self"]]],[11,"TAU","","Return the full circle constant `τ`.",56,[[],["self"]]],[11,"LOG10_2","","Return `log10(2.0)`.",56,[[],["self"]]],[11,"LOG2_10","","Return `log2(10.0)`.",56,[[],["self"]]],[0,"identities","argmin::prelude","",null,null],[8,"Zero","argmin::prelude::identities","Defines an additive identity element for `Self`.",null,null],[10,"zero","","Returns the additive identity element of `Self`, `0`. #…",57,[[],["self"]]],[11,"set_zero","","Sets `self` to the additive identity element of `Self`, `0`.",57,[[["self"]]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",57,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",null,null],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",58,[[],["self"]]],[11,"set_one","","Sets `self` to the multiplicative identity element of…",58,[[["self"]]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative…",58,[[["self"]],["bool"]]],[5,"zero","","Returns the additive identity, `0`.",null,[[],["t"]]],[5,"one","","Returns the multiplicative identity, `1`.",null,[[],["t"]]],[0,"int","argmin::prelude","",null,null],[8,"PrimInt","argmin::prelude::int","Generic trait for primitive integers.",null,null],[10,"count_ones","","Returns the number of ones in the binary representation of…",59,[[],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation…",59,[[],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary…",59,[[],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary…",59,[[],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount, `n`,…",59,[[["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount, `n`,…",59,[[["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount, `n`,…",59,[[["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount, `n`,…",59,[[["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount, `n`,…",59,[[["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount, `n`,…",59,[[["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",59,[[],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's…",59,[[],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's…",59,[[],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",59,[[],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's…",59,[[],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by…",59,[[["u32"]],["self"]]],[0,"ops","argmin::prelude","",null,null],[0,"checked","argmin::prelude::ops","",null,null],[8,"CheckedAdd","argmin::prelude::ops::checked","Performs addition that returns `None` instead of wrapping…",null,null],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow…",60,[[["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of…",null,null],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If…",61,[[["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of…",null,null],[10,"checked_mul","","Multiplies two numbers, checking for underflow or…",62,[[["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking…",null,null],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and…",63,[[["self"]],["option"]]],[8,"CheckedRem","","Performs an integral remainder that returns `None` instead…",null,null],[10,"checked_rem","","Finds the remainder of dividing two numbers, checking for…",64,[[["self"]],["option"]]],[8,"CheckedNeg","","Performs negation that returns `None` if the result can't…",null,null],[10,"checked_neg","","Negates a number, returning `None` for results that can't…",65,[[["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on shifts larger…",null,null],[10,"checked_shl","","Checked shift left. Computes `self << rhs`, returning…",66,[[["u32"],["self"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on shifts…",null,null],[10,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning…",67,[[["u32"],["self"]],["option"]]],[0,"inv","argmin::prelude::ops","",null,null],[8,"Inv","argmin::prelude::ops::inv","Unary operator for retrieving the multiplicative inverse,…",null,null],[16,"Output","","The result after applying the operator.",68,null],[10,"inv","","Returns the multiplicative inverse of `self`.",68,[[]]],[0,"mul_add","argmin::prelude::ops","",null,null],[8,"MulAdd","argmin::prelude::ops::mul_add","Fused multiply-add. Computes `(self * a) + b` with only…",null,null],[16,"Output","","The resulting type after applying the fused multiply-add.",69,null],[10,"mul_add","","Performs the fused multiply-add operation.",69,[[["a"],["b"]]]],[8,"MulAddAssign","","The fused multiply-add assignment operation.",null,null],[10,"mul_add_assign","","Performs the fused multiply-add operation.",70,[[["a"],["self"],["b"]]]],[0,"saturating","argmin::prelude::ops","",null,null],[8,"Saturating","argmin::prelude::ops::saturating","Saturating math operations. Deprecated, use…",null,null],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at…",71,[[],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating…",71,[[],["self"]]],[8,"SaturatingAdd","","Performs addition that saturates at the numeric bounds…",null,null],[10,"saturating_add","","Saturating addition. Computes `self + other`, saturating…",72,[[["self"]],["self"]]],[8,"SaturatingSub","","Performs subtraction that saturates at the numeric bounds…",null,null],[10,"saturating_sub","","Saturating subtraction. Computes `self - other`,…",73,[[["self"]],["self"]]],[8,"SaturatingMul","","Performs multiplication that saturates at the numeric…",null,null],[10,"saturating_mul","","Saturating multiplication. Computes `self * other`,…",74,[[["self"]],["self"]]],[0,"wrapping","argmin::prelude::ops","",null,null],[8,"WrappingAdd","argmin::prelude::ops::wrapping","Performs addition that wraps around on overflow.",null,null],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`,…",75,[[["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",null,null],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`,…",76,[[["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",null,null],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self *…",77,[[["self"]],["self"]]],[8,"WrappingNeg","","Performs a negation that does not panic.",null,null],[10,"wrapping_neg","","Wrapping (modular) negation. Computes `-self`, wrapping…",78,[[["self"]],["self"]]],[8,"WrappingShl","","Performs a left shift that does not panic.",null,null],[10,"wrapping_shl","","Panic-free bitwise shift-left; yields `self << mask(rhs)`,…",79,[[["u32"],["self"]],["self"]]],[8,"WrappingShr","","Performs a right shift that does not panic.",null,null],[10,"wrapping_shr","","Panic-free bitwise shift-right; yields `self >>…",80,[[["u32"],["self"]],["self"]]],[0,"pow","argmin::prelude","",null,null],[8,"Pow","argmin::prelude::pow","Binary operator for raising a value to a power.",null,null],[16,"Output","","The result after applying the operator.",81,null],[10,"pow","","Returns `self` to the power `rhs`.",81,[[["rhs"]]]],[5,"pow","","Raises a value to the power of exp, using exponentiation…",null,[[["t"],["usize"]],["t"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an…",null,[[["t"],["usize"]],["option"]]],[0,"real","argmin::prelude","",null,null],[8,"Real","argmin::prelude::real","A trait for real number types that do not necessarily have…",null,null],[10,"min_value","","Returns the smallest finite value that this type can…",82,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",82,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",82,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",82,[[],["self"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",82,[[],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a…",82,[[],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way…",82,[[],["self"]]],[10,"trunc","","Return the integer part of a number.",82,[[],["self"]]],[10,"fract","","Returns the fractional part of a number.",82,[[],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns…",82,[[],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",82,[[],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`,…",82,[[],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`,…",82,[[],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only…",82,[[],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",82,[[],["self"]]],[10,"powi","","Raise a number to an integer power.",82,[[["i32"]],["self"]]],[10,"powf","","Raise a number to a real number power.",82,[[],["self"]]],[10,"sqrt","","Take the square root of a number.",82,[[],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",82,[[],["self"]]],[10,"exp2","","Returns `2^(self)`.",82,[[],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",82,[[],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an…",82,[[],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",82,[[],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",82,[[],["self"]]],[10,"to_degrees","","Converts radians to degrees.",82,[[],["self"]]],[10,"to_radians","","Converts degrees to radians.",82,[[],["self"]]],[10,"max","","Returns the maximum of the two numbers.",82,[[],["self"]]],[10,"min","","Returns the minimum of the two numbers.",82,[[],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",82,[[],["self"]]],[10,"cbrt","","Take the cubic root of a number.",82,[[],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle…",82,[[],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",82,[[],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",82,[[],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",82,[[],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in…",82,[[],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in…",82,[[],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in…",82,[[],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and…",82,[[],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number,…",82,[[]]],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if…",82,[[],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than…",82,[[],["self"]]],[10,"sinh","","Hyperbolic sine function.",82,[[],["self"]]],[10,"cosh","","Hyperbolic cosine function.",82,[[],["self"]]],[10,"tanh","","Hyperbolic tangent function.",82,[[],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",82,[[],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",82,[[],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",82,[[],["self"]]],[0,"sign","argmin::prelude","",null,null],[8,"Signed","argmin::prelude::sign","Useful functions for signed numbers (i.e. numbers that can…",null,null],[10,"abs","","Computes the absolute value.",83,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",83,[[["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",83,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the…",83,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the…",83,[[["self"]],["bool"]]],[5,"abs","","Computes the absolute value.",null,[[["t"]],["t"]]],[5,"abs_sub","","The positive difference of two numbers.",null,[[["t"]],["t"]]],[5,"signum","","Returns the sign of the number.",null,[[["t"]],["t"]]],[8,"Unsigned","","A trait for values which cannot be negative",null,null],[8,"Num","argmin::prelude","The base trait for numeric types, covering `0` and `1`…",null,null],[16,"FromStrRadixErr","","",84,null],[10,"from_str_radix","","Convert from a string and radix <= 36.",84,[[["str"],["u32"]],["result"]]],[8,"NumOps","","The trait for types implementing basic numeric operations",null,null],[8,"NumRef","","The trait for `Num` types which also implement numeric…",null,null],[8,"RefNum","","The trait for references which implement numeric…",null,null],[8,"NumAssignOps","","The trait for types implementing numeric assignment…",null,null],[8,"NumAssign","","The trait for `Num` types which also implement assignment…",null,null],[8,"NumAssignRef","","The trait for `NumAssign` types which also implement…",null,null],[4,"FloatErrorKind","","",null,null],[13,"Empty","","",85,null],[13,"Invalid","","",85,null],[3,"ParseFloatError","","",null,null],[12,"kind","","",86,null],[5,"clamp","","A value bounded by a minimum and a maximum",null,[[["t"]],["t"]]],[5,"clamp_min","","A value bounded by a minimum value",null,[[["t"]],["t"]]],[5,"clamp_max","","A value bounded by a maximum value",null,[[["t"]],["t"]]],[8,"Bounded","","Numbers which have upper and lower bounds",null,null],[10,"min_value","","returns the smallest finite number this type can represent",49,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",49,[[],["self"]]],[8,"Float","","Generic trait for floating point numbers",null,null],[10,"nan","","Returns the `NaN` value.",55,[[],["self"]]],[10,"infinity","","Returns the infinite value.",55,[[],["self"]]],[10,"neg_infinity","","Returns the negative infinite value.",55,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",55,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can…",55,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",55,[[],["self"]]],[11,"epsilon","","Returns epsilon, a small positive value.",55,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",55,[[],["self"]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",55,[[],["bool"]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or…",55,[[],["bool"]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",55,[[],["bool"]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite,…",55,[[],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only…",55,[[],["fpcategory"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",55,[[],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a…",55,[[],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way…",55,[[],["self"]]],[10,"trunc","","Return the integer part of a number.",55,[[],["self"]]],[10,"fract","","Returns the fractional part of a number.",55,[[],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns…",55,[[],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",55,[[],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`,…",55,[[],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`,…",55,[[],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only…",55,[[],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",55,[[],["self"]]],[10,"powi","","Raise a number to an integer power.",55,[[["i32"]],["self"]]],[10,"powf","","Raise a number to a floating point power.",55,[[],["self"]]],[10,"sqrt","","Take the square root of a number.",55,[[],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",55,[[],["self"]]],[10,"exp2","","Returns `2^(self)`.",55,[[],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",55,[[],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an…",55,[[],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",55,[[],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",55,[[],["self"]]],[11,"to_degrees","","Converts radians to degrees.",55,[[],["self"]]],[11,"to_radians","","Converts degrees to radians.",55,[[],["self"]]],[10,"max","","Returns the maximum of the two numbers.",55,[[],["self"]]],[10,"min","","Returns the minimum of the two numbers.",55,[[],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",55,[[],["self"]]],[10,"cbrt","","Take the cubic root of a number.",55,[[],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle…",55,[[],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",55,[[],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",55,[[],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",55,[[],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in…",55,[[],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in…",55,[[],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in…",55,[[],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and…",55,[[],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number,…",55,[[]]],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if…",55,[[],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than…",55,[[],["self"]]],[10,"sinh","","Hyperbolic sine function.",55,[[],["self"]]],[10,"cosh","","Hyperbolic cosine function.",55,[[],["self"]]],[10,"tanh","","Hyperbolic tangent function.",55,[[],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",55,[[],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",55,[[],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",55,[[],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",55,[[]]],[8,"FloatConst","","",null,null],[10,"E","","Return Euler’s number.",56,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",56,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",56,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",56,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",56,[[],["self"]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",56,[[],["self"]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",56,[[],["self"]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",56,[[],["self"]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",56,[[],["self"]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",56,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",56,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",56,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",56,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",56,[[],["self"]]],[10,"PI","","Return Archimedes’ constant `π`.",56,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",56,[[],["self"]]],[11,"TAU","","Return the full circle constant `τ`.",56,[[],["self"]]],[11,"LOG10_2","","Return `log10(2.0)`.",56,[[],["self"]]],[11,"LOG2_10","","Return `log2(10.0)`.",56,[[],["self"]]],[5,"cast","","Cast from one machine scalar to another.",null,[[["t"]],["option"]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars…",null,null],[10,"as_","","Convert a value to another, using the `as` operator.",53,[[],["t"]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Converts an `isize` to return an optional value of this…",51,[[["isize"]],["option"]]],[11,"from_i8","","Converts an `i8` to return an optional value of this type.…",51,[[["i8"]],["option"]]],[11,"from_i16","","Converts an `i16` to return an optional value of this…",51,[[["i16"]],["option"]]],[11,"from_i32","","Converts an `i32` to return an optional value of this…",51,[[["i32"]],["option"]]],[10,"from_i64","","Converts an `i64` to return an optional value of this…",51,[[["i64"]],["option"]]],[11,"from_i128","","Converts an `i128` to return an optional value of this…",51,[[["i128"]],["option"]]],[11,"from_usize","","Converts a `usize` to return an optional value of this…",51,[[["usize"]],["option"]]],[11,"from_u8","","Converts an `u8` to return an optional value of this type.…",51,[[["u8"]],["option"]]],[11,"from_u16","","Converts an `u16` to return an optional value of this…",51,[[["u16"]],["option"]]],[11,"from_u32","","Converts an `u32` to return an optional value of this…",51,[[["u32"]],["option"]]],[10,"from_u64","","Converts an `u64` to return an optional value of this…",51,[[["u64"]],["option"]]],[11,"from_u128","","Converts an `u128` to return an optional value of this…",51,[[["u128"]],["option"]]],[11,"from_f32","","Converts a `f32` to return an optional value of this type.…",51,[[["f32"]],["option"]]],[11,"from_f64","","Converts a `f64` to return an optional value of this type.…",51,[[["f64"]],["option"]]],[8,"NumCast","","An interface for casting between machine scalars.",null,null],[10,"from","","Creates a number from another value that can be converted…",52,[[["t"]],["option"]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",null,null],[11,"to_isize","","Converts the value of `self` to an `isize`. If the value…",50,[[["self"]],[["option",["isize"]],["isize"]]]],[11,"to_i8","","Converts the value of `self` to an `i8`. If the value…",50,[[["self"]],[["option",["i8"]],["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`. If the value…",50,[[["self"]],[["option",["i16"]],["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`. If the value…",50,[[["self"]],[["option",["i32"]],["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`. If the value…",50,[[["self"]],[["i64"],["option",["i64"]]]]],[11,"to_i128","","Converts the value of `self` to an `i128`. If the value…",50,[[["self"]],[["i128"],["option",["i128"]]]]],[11,"to_usize","","Converts the value of `self` to a `usize`. If the value…",50,[[["self"]],[["option",["usize"]],["usize"]]]],[11,"to_u8","","Converts the value of `self` to a `u8`. If the value…",50,[[["self"]],[["u8"],["option",["u8"]]]]],[11,"to_u16","","Converts the value of `self` to a `u16`. If the value…",50,[[["self"]],[["u16"],["option",["u16"]]]]],[11,"to_u32","","Converts the value of `self` to a `u32`. If the value…",50,[[["self"]],[["option",["u32"]],["u32"]]]],[10,"to_u64","","Converts the value of `self` to a `u64`. If the value…",50,[[["self"]],[["option",["u64"]],["u64"]]]],[11,"to_u128","","Converts the value of `self` to a `u128`. If the value…",50,[[["self"]],[["option",["u128"]],["u128"]]]],[11,"to_f32","","Converts the value of `self` to an `f32`. If the value…",50,[[["self"]],[["f32"],["option",["f32"]]]]],[11,"to_f64","","Converts the value of `self` to an `f64`. If the value…",50,[[["self"]],[["option",["f64"]],["f64"]]]],[5,"one","","Returns the multiplicative identity, `1`.",null,[[],["t"]]],[5,"zero","","Returns the additive identity, `0`.",null,[[],["t"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",null,null],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",58,[[],["self"]]],[11,"set_one","","Sets `self` to the multiplicative identity element of…",58,[[["self"]]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative…",58,[[["self"]],["bool"]]],[8,"Zero","","Defines an additive identity element for `Self`.",null,null],[10,"zero","","Returns the additive identity element of `Self`, `0`. #…",57,[[],["self"]]],[11,"set_zero","","Sets `self` to the additive identity element of `Self`, `0`.",57,[[["self"]]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",57,[[["self"]],["bool"]]],[8,"PrimInt","","Generic trait for primitive integers.",null,null],[10,"count_ones","","Returns the number of ones in the binary representation of…",59,[[],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation…",59,[[],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary…",59,[[],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary…",59,[[],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount, `n`,…",59,[[["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount, `n`,…",59,[[["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount, `n`,…",59,[[["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount, `n`,…",59,[[["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount, `n`,…",59,[[["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount, `n`,…",59,[[["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",59,[[],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's…",59,[[],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's…",59,[[],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",59,[[],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's…",59,[[],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by…",59,[[["u32"]],["self"]]],[8,"CheckedAdd","","Performs addition that returns `None` instead of wrapping…",null,null],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow…",60,[[["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking…",null,null],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and…",63,[[["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of…",null,null],[10,"checked_mul","","Multiplies two numbers, checking for underflow or…",62,[[["self"]],["option"]]],[8,"CheckedNeg","","Performs negation that returns `None` if the result can't…",null,null],[10,"checked_neg","","Negates a number, returning `None` for results that can't…",65,[[["self"]],["option"]]],[8,"CheckedRem","","Performs an integral remainder that returns `None` instead…",null,null],[10,"checked_rem","","Finds the remainder of dividing two numbers, checking for…",64,[[["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on shifts larger…",null,null],[10,"checked_shl","","Checked shift left. Computes `self << rhs`, returning…",66,[[["u32"],["self"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on shifts…",null,null],[10,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning…",67,[[["u32"],["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of…",null,null],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If…",61,[[["self"]],["option"]]],[8,"Inv","","Unary operator for retrieving the multiplicative inverse,…",null,null],[16,"Output","","The result after applying the operator.",68,null],[10,"inv","","Returns the multiplicative inverse of `self`.",68,[[]]],[8,"MulAdd","","Fused multiply-add. Computes `(self * a) + b` with only…",null,null],[16,"Output","","The resulting type after applying the fused multiply-add.",69,null],[10,"mul_add","","Performs the fused multiply-add operation.",69,[[["a"],["b"]]]],[8,"MulAddAssign","","The fused multiply-add assignment operation.",null,null],[10,"mul_add_assign","","Performs the fused multiply-add operation.",70,[[["a"],["self"],["b"]]]],[8,"Saturating","","Saturating math operations. Deprecated, use…",null,null],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at…",71,[[],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating…",71,[[],["self"]]],[8,"SaturatingAdd","","Performs addition that saturates at the numeric bounds…",null,null],[10,"saturating_add","","Saturating addition. Computes `self + other`, saturating…",72,[[["self"]],["self"]]],[8,"SaturatingMul","","Performs multiplication that saturates at the numeric…",null,null],[10,"saturating_mul","","Saturating multiplication. Computes `self * other`,…",74,[[["self"]],["self"]]],[8,"SaturatingSub","","Performs subtraction that saturates at the numeric bounds…",null,null],[10,"saturating_sub","","Saturating subtraction. Computes `self - other`,…",73,[[["self"]],["self"]]],[8,"WrappingAdd","","Performs addition that wraps around on overflow.",null,null],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`,…",75,[[["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",null,null],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self *…",77,[[["self"]],["self"]]],[8,"WrappingNeg","","Performs a negation that does not panic.",null,null],[10,"wrapping_neg","","Wrapping (modular) negation. Computes `-self`, wrapping…",78,[[["self"]],["self"]]],[8,"WrappingShl","","Performs a left shift that does not panic.",null,null],[10,"wrapping_shl","","Panic-free bitwise shift-left; yields `self << mask(rhs)`,…",79,[[["u32"],["self"]],["self"]]],[8,"WrappingShr","","Performs a right shift that does not panic.",null,null],[10,"wrapping_shr","","Panic-free bitwise shift-right; yields `self >>…",80,[[["u32"],["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",null,null],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`,…",76,[[["self"]],["self"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an…",null,[[["t"],["usize"]],["option"]]],[5,"pow","","Raises a value to the power of exp, using exponentiation…",null,[[["t"],["usize"]],["t"]]],[8,"Pow","","Binary operator for raising a value to a power.",null,null],[16,"Output","","The result after applying the operator.",81,null],[10,"pow","","Returns `self` to the power `rhs`.",81,[[["rhs"]]]],[5,"abs","","Computes the absolute value.",null,[[["t"]],["t"]]],[5,"abs_sub","","The positive difference of two numbers.",null,[[["t"]],["t"]]],[5,"signum","","Returns the sign of the number.",null,[[["t"]],["t"]]],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can…",null,null],[10,"abs","","Computes the absolute value.",83,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",83,[[["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",83,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the…",83,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the…",83,[[["self"]],["bool"]]],[8,"Unsigned","","A trait for values which cannot be negative",null,null],[0,"solver","argmin","Solvers",null,null],[0,"brent","argmin::solver","Brent's method",null,null],[3,"Brent","argmin::solver::brent","Brent's method",null,null],[4,"BrentError","","Error to be thrown if Brent is initialized with improper…",null,null],[13,"WrongSign","","f(min) and f(max) must have different signs",87,null],[11,"new","","Constructor The values `min` and `max` must bracketing the…",88,[[["f"]],["brent"]]],[0,"conjugategradient","argmin::solver","Conjugate Gradient methods",null,null],[0,"cg","argmin::solver::conjugategradient","Conjugate gradient method # References:",null,null],[3,"ConjugateGradient","argmin::solver::conjugategradient::cg","The conjugate gradient method is a solver for systems of…",null,null],[11,"new","","Constructor",89,[[["p"]],[["result",["error"]],["error"]]]],[11,"p","","Return the current search direction (This is needed by…",89,[[["self"]],["p"]]],[11,"p_prev","","Return the previous search direction (This is needed by…",89,[[["self"]],["p"]]],[11,"residual","","Return the current residual (This is needed by NewtonCG…",89,[[["self"]],["p"]]],[0,"nonlinear_cg","argmin::solver::conjugategradient","Nonlinear conjugate gradient method Important TODO: Find…",null,null],[3,"NonlinearConjugateGradient","argmin::solver::conjugategradient::nonlinear_cg","The nonlinear conjugate gradient is a generalization of…",null,null],[11,"new","","Constructor (Polak Ribiere Conjugate Gradient (PR-CG))",90,[[["b"],["l"]],[["result",["error"]],["error"]]]],[11,"restart_iters","","Specifiy the number of iterations after which a restart…",90,[[["u64"]],["self"]]],[11,"restart_orthogonality","","Set the value for the orthogonality measure. Setting this…",90,[[["f"]],["self"]]],[0,"beta","argmin::solver::conjugategradient","Beta update methods for nonlinear CG # Beta update methods",null,null],[3,"FletcherReeves","argmin::solver::conjugategradient::beta","Fletcher and Reeves (FR) method TODO: Reference",null,null],[3,"PolakRibiere","","Polak and Ribiere (PR) method TODO: Reference",null,null],[3,"PolakRibierePlus","","Polak and Ribiere Plus (PR+) method TODO: Reference",null,null],[3,"HestenesStiefel","","Hestenes and Stiefel (HS) method TODO: Reference",null,null],[11,"new","","Constructor",91,[[],["self"]]],[11,"new","","Constructor",92,[[],["self"]]],[11,"new","","Constructor",93,[[],["self"]]],[11,"new","","Constructor",94,[[],["self"]]],[0,"gaussnewton","argmin::solver","Newton Methods",null,null],[0,"gaussnewton_linesearch","argmin::solver::gaussnewton","Gauss-Newton method with linesearch # References:",null,null],[3,"GaussNewtonLS","argmin::solver::gaussnewton::gaussnewton_linesearch","Gauss-Newton method with linesearch",null,null],[11,"new","","Constructor",95,[[["l"]],["self"]]],[11,"with_tol","","Set tolerance for the stopping criterion based on cost…",95,[[["f"]],[["result",["error"]],["error"]]]],[0,"gaussnewton_method","argmin::solver::gaussnewton","Gauss-Newton method # References:",null,null],[3,"GaussNewton","argmin::solver::gaussnewton::gaussnewton_method","Gauss-Newton method",null,null],[11,"new","","Constructor",96,[[],["self"]]],[11,"with_gamma","","set gamma",96,[[["f"]],[["result",["error"]],["error"]]]],[11,"with_tol","","Set tolerance for the stopping criterion based on cost…",96,[[["f"]],[["result",["error"]],["error"]]]],[0,"goldensectionsearch","argmin::solver","References:",null,null],[3,"GoldenSectionSearch","argmin::solver::goldensectionsearch","Golden-section search",null,null],[11,"new","","Constructor",97,[[["f"]],["self"]]],[11,"tolerance","","Set tolerance",97,[[["f"]],["self"]]],[0,"gradientdescent","argmin::solver","Gradient descent methods",null,null],[0,"steepestdescent","argmin::solver::gradientdescent","Steepest Descent method",null,null],[3,"SteepestDescent","argmin::solver::gradientdescent::steepestdescent","Steepest descent iteratively takes steps in the direction…",null,null],[11,"new","","Constructor",98,[[["l"]],["self"]]],[0,"landweber","argmin::solver","Landweber iteration",null,null],[3,"Landweber","argmin::solver::landweber","The Landweber iteration is a solver for ill-posed linear…",null,null],[11,"new","","Constructor",99,[[["f"]],["self"]]],[0,"linesearch","argmin::solver","Line search methods",null,null],[0,"backtracking","argmin::solver::linesearch","Backtracking line search algorithm * Backtracking line…",null,null],[3,"BacktrackingLineSearch","argmin::solver::linesearch::backtracking","The Backtracking line search is a simple method to find a…",null,null],[11,"new","","Constructor",100,[[["l"]],["self"]]],[11,"rho","","Set rho",100,[[["f"]],[["result",["error"]],["error"]]]],[0,"condition","argmin::solver::linesearch","Acceptance conditions # References:",null,null],[3,"ArmijoCondition","argmin::solver::linesearch::condition","Armijo Condition",null,null],[3,"WolfeCondition","","Wolfe Condition",null,null],[3,"StrongWolfeCondition","","Strong Wolfe conditions",null,null],[3,"GoldsteinCondition","","Goldstein conditions",null,null],[8,"LineSearchCondition","","Needs to be implemented by everything that wants to be a…",null,null],[10,"eval","","Evaluate the condition",101,[[["t"],["self"],["f"]],["bool"]]],[10,"requires_cur_grad","","Indicates whether this condition requires the computation…",101,[[["self"]],["bool"]]],[11,"new","","Constructor",102,[[["f"]],[["result",["error"]],["error"]]]],[11,"new","","Constructor",103,[[["f"]],[["result",["error"]],["error"]]]],[11,"new","","Constructor",104,[[["f"]],[["result",["error"]],["error"]]]],[11,"new","","Constructor",105,[[["f"]],[["result",["error"]],["error"]]]],[0,"hagerzhang","argmin::solver::linesearch","Hager-Zhang line search algorithm * Hager-Zhang line search",null,null],[3,"HagerZhangLineSearch","argmin::solver::linesearch::hagerzhang","The Hager-Zhang line search is a method to find a step…",null,null],[11,"new","","Constructor",106,[[],["self"]]],[11,"delta","","set delta",106,[[["f"]],[["result",["error"]],["error"]]]],[11,"sigma","","set sigma",106,[[["f"]],[["result",["error"]],["error"]]]],[11,"epsilon","","set epsilon",106,[[["f"]],[["result",["error"]],["error"]]]],[11,"theta","","set theta",106,[[["f"]],[["result",["error"]],["error"]]]],[11,"gamma","","set gamma",106,[[["f"]],[["result",["error"]],["error"]]]],[11,"eta","","set eta",106,[[["f"]],[["result",["error"]],["error"]]]],[11,"alpha","","set alpha limits",106,[[["f"]],[["result",["error"]],["error"]]]],[0,"morethuente","argmin::solver::linesearch","More-Thuente line search algorithm * More-Thuente line…",null,null],[3,"MoreThuenteLineSearch","argmin::solver::linesearch::morethuente","The More-Thuente line search is a method to find a step…",null,null],[11,"new","","Constructor",107,[[],["self"]]],[11,"c","","Set c1 and c2 where 0 < c1 < c2 < 1.",107,[[["f"]],[["result",["error"]],["error"]]]],[11,"alpha","","set alpha limits",107,[[["f"]],[["result",["error"]],["error"]]]],[0,"neldermead","argmin::solver","References:",null,null],[3,"NelderMead","argmin::solver::neldermead","Nelder-Mead method",null,null],[11,"new","","Constructor",108,[[],["self"]]],[11,"with_initial_params","","Add initial parameters",108,[[["vec"]],["self"]]],[11,"sd_tolerance","","Set Sample standard deviation tolerance",108,[[["f"]],["self"]]],[11,"alpha","","set alpha",108,[[["f"]],[["result",["error"]],["error"]]]],[11,"gamma","","set gamma",108,[[["f"]],[["result",["error"]],["error"]]]],[11,"rho","","set rho",108,[[["f"]],[["result",["error"]],["error"]]]],[11,"sigma","","set sigma",108,[[["f"]],[["result",["error"]],["error"]]]],[0,"newton","argmin::solver","Newton Methods",null,null],[0,"newton_cg","argmin::solver::newton","Newton-CG method TODO: Stop when search direction is close…",null,null],[3,"NewtonCG","argmin::solver::newton::newton_cg","The Newton-CG method (also called truncated Newton method)…",null,null],[11,"new","","Constructor",109,[[["l"]],["self"]]],[11,"curvature_threshold","","Set curvature threshold",109,[[["f"]],["self"]]],[11,"with_tol","","Set tolerance for the stopping criterion based on cost…",109,[[["f"]],[["result",["error"]],["error"]]]],[0,"newton_method","argmin::solver::newton","Newton's method # References:",null,null],[3,"Newton","argmin::solver::newton::newton_method","Newton's method iteratively finds the stationary points of…",null,null],[11,"new","","Constructor",110,[[],["self"]]],[11,"set_gamma","","set gamma",110,[[["f"]],[["result",["error"]],["error"]]]],[0,"particleswarm","argmin::solver","References:",null,null],[3,"ParticleSwarm","argmin::solver::particleswarm","Particle Swarm Optimization (PSO)",null,null],[3,"Particle","","A single particle",null,null],[12,"position","","Position of particle",111,null],[12,"cost","","Cost of particle",111,null],[8,"Position","","Position",null,null],[11,"new","","Constructor",112,[[["f"],["usize"]],[["result",["error"]],["error"]]]],[0,"quasinewton","argmin::solver","Quasi-Newton methods",null,null],[0,"bfgs","argmin::solver::quasinewton","References:",null,null],[3,"BFGS","argmin::solver::quasinewton::bfgs","BFGS method",null,null],[11,"new","","Constructor",113,[[["l"],["h"]],["self"]]],[11,"with_tol_grad","","Sets tolerance for the stopping criterion based on the…",113,[[["f"]],["self"]]],[11,"with_tol_cost","","Sets tolerance for the stopping criterion based on the…",113,[[["f"]],["self"]]],[0,"dfp","argmin::solver::quasinewton","References:",null,null],[3,"DFP","argmin::solver::quasinewton::dfp","DFP method",null,null],[11,"new","","Constructor",114,[[["l"],["h"]],["self"]]],[11,"with_tol_grad","","Sets tolerance for the stopping criterion based on the…",114,[[["f"]],["self"]]],[0,"lbfgs","argmin::solver::quasinewton","References:",null,null],[3,"LBFGS","argmin::solver::quasinewton::lbfgs","L-BFGS method",null,null],[11,"new","","Constructor",115,[[["usize"],["l"]],["self"]]],[11,"with_tol_grad","","Sets tolerance for the stopping criterion based on the…",115,[[["f"]],["self"]]],[11,"with_tol_cost","","Sets tolerance for the stopping criterion based on the…",115,[[["f"]],["self"]]],[0,"sr1","argmin::solver::quasinewton","References:",null,null],[3,"SR1","argmin::solver::quasinewton::sr1","SR1 method (broken!)",null,null],[11,"new","","Constructor",116,[[["l"],["h"]],["self"]]],[11,"r","","Set r",116,[[["f"]],[["result",["error"]],["error"]]]],[11,"with_tol_grad","","Sets tolerance for the stopping criterion based on the…",116,[[["f"]],["self"]]],[11,"with_tol_cost","","Sets tolerance for the stopping criterion based on the…",116,[[["f"]],["self"]]],[0,"sr1_trustregion","argmin::solver::quasinewton","References:",null,null],[3,"SR1TrustRegion","argmin::solver::quasinewton::sr1_trustregion","SR1 Trust Region method",null,null],[11,"new","","Constructor",117,[[["r"]],["self"]]],[11,"hessian","","provide initial Hessian (if not provided, the algorithm…",117,[[["b"]],["self"]]],[11,"r","","Set r",117,[[["f"]],[["result",["error"]],["error"]]]],[11,"radius","","set radius",117,[[["f"]],["self"]]],[11,"eta","","Set eta",117,[[["f"]],[["result",["error"]],["error"]]]],[11,"with_tol_grad","","Sets tolerance for the stopping criterion based on the…",117,[[["f"]],["self"]]],[0,"simulatedannealing","argmin::solver","",null,null],[3,"SimulatedAnnealing","argmin::solver::simulatedannealing","Simulated Annealing",null,null],[4,"SATempFunc","","Temperature functions for Simulated Annealing.",null,null],[13,"TemperatureFast","","`t_i = t_init / i`",118,null],[13,"Boltzmann","","`t_i = t_init / ln(i)`",118,null],[13,"Exponential","","`t_i = t_init * x^i`",118,null],[11,"new","","Constructor",119,[[["f"]],[["result",["error"]],["error"]]]],[11,"temp_func","","Set temperature function to one of the options in…",119,[[["satempfunc"]],["self"]]],[11,"stall_accepted","","The optimization stops after there has been no accepted…",119,[[["u64"]],["self"]]],[11,"stall_best","","The optimization stops after there has been no new best…",119,[[["u64"]],["self"]]],[11,"reannealing_fixed","","Start reannealing after `iter` iterations",119,[[["u64"]],["self"]]],[11,"reannealing_accepted","","Start reannealing after no accepted solution has been…",119,[[["u64"]],["self"]]],[11,"reannealing_best","","Start reannealing after no new best solution has been…",119,[[["u64"]],["self"]]],[0,"trustregion","argmin::solver","Argmin Trust region methods",null,null],[5,"reduction_ratio","argmin::solver::trustregion","Computes reduction ratio",null,[[["argminfloat"]],["argminfloat"]]],[0,"cauchypoint","","Cauchy Point # References:",null,null],[3,"CauchyPoint","argmin::solver::trustregion::cauchypoint","The Cauchy point is the minimum of the quadratic…",null,null],[11,"new","","Constructor",120,[[],["self"]]],[0,"dogleg","argmin::solver::trustregion","Dogleg method # References:",null,null],[3,"Dogleg","argmin::solver::trustregion::dogleg","The Dogleg method computes the intersection of the trust…",null,null],[11,"new","","Constructor",121,[[],["self"]]],[0,"steihaug","argmin::solver::trustregion","Steihaug method # References:",null,null],[3,"Steihaug","argmin::solver::trustregion::steihaug","The Steihaug method is a conjugate gradients based…",null,null],[11,"new","","Constructor",122,[[],["self"]]],[11,"epsilon","","Set epsilon",122,[[["f"]],[["result",["error"]],["error"]]]],[11,"max_iters","","set maximum number of iterations",122,[[["u64"]],["self"]]],[0,"trustregion_method","argmin::solver::trustregion","Trust region solver # References:",null,null],[3,"TrustRegion","argmin::solver::trustregion::trustregion_method","The trust region method approximates the cost function…",null,null],[11,"new","","Constructor",123,[[["r"]],["self"]]],[11,"radius","","set radius",123,[[["f"]],["self"]]],[11,"max_radius","","Set maximum radius",123,[[["f"]],["self"]]],[11,"eta","","Set eta",123,[[["f"]],[["result",["error"]],["error"]]]],[14,"make_kv","argmin","Creates an `ArgminKV` at compile time in order to avoid…",null,null],[14,"check_param","","Release an `T` from an `Option<T>` if it is not `None`. If…",null,null],[14,"trait_bound","","Reuse a list of trait bounds by giving it a name, e.g.…",null,null],[11,"from","argmin::core","",124,[[],["t"]]],[11,"from","","",124,[[["t"]],["t"]]],[11,"into","","",124,[[],["u"]]],[11,"to_string","","",124,[[["self"]],["string"]]],[11,"try_from","","",124,[[["u"]],["result"]]],[11,"try_into","","",124,[[],["result"]]],[11,"borrow","","",124,[[["self"]],["t"]]],[11,"borrow_mut","","",124,[[["self"]],["t"]]],[11,"type_id","","",124,[[["self"]],["typeid"]]],[11,"vzip","","",124,[[],["v"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,[[["self"],["t"]]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"vzip","","",0,[[],["v"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,[[["self"],["t"]]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"vzip","","",1,[[],["v"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,[[["self"],["t"]]]],[11,"to_string","","",17,[[["self"]],["string"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"type_id","","",17,[[["self"]],["typeid"]]],[11,"vzip","","",17,[[],["v"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[],["u"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,[[["self"],["t"]]]],[11,"to_string","","",18,[[["self"]],["string"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"type_id","","",18,[[["self"]],["typeid"]]],[11,"vzip","","",18,[[],["v"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[],["u"]]],[11,"to_owned","","",19,[[["self"]],["t"]]],[11,"clone_into","","",19,[[["self"],["t"]]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"type_id","","",19,[[["self"]],["typeid"]]],[11,"vzip","","",19,[[],["v"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"into","","",20,[[],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,[[["self"],["t"]]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"type_id","","",20,[[["self"]],["typeid"]]],[11,"vzip","","",20,[[],["v"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"vzip","","",2,[[],["v"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[],["u"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"type_id","","",21,[[["self"]],["typeid"]]],[11,"vzip","","",21,[[],["v"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"into","","",22,[[],["u"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"type_id","","",22,[[["self"]],["typeid"]]],[11,"vzip","","",22,[[],["v"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"into","","",23,[[],["u"]]],[11,"to_owned","","",23,[[["self"]],["t"]]],[11,"clone_into","","",23,[[["self"],["t"]]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"type_id","","",23,[[["self"]],["typeid"]]],[11,"vzip","","",23,[[],["v"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,[[["self"],["t"]]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"vzip","","",3,[[],["v"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,[[["self"],["t"]]]],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"vzip","","",4,[[],["v"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"into","","",24,[[],["u"]]],[11,"to_owned","","",24,[[["self"]],["t"]]],[11,"clone_into","","",24,[[["self"],["t"]]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"try_into","","",24,[[],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"type_id","","",24,[[["self"]],["typeid"]]],[11,"vzip","","",24,[[],["v"]]],[11,"from","","",48,[[["t"]],["t"]]],[11,"into","","",48,[[],["u"]]],[11,"to_owned","","",48,[[["self"]],["t"]]],[11,"clone_into","","",48,[[["self"],["t"]]]],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"try_into","","",48,[[],["result"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"type_id","","",48,[[["self"]],["typeid"]]],[11,"vzip","","",48,[[],["v"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"to_string","","",5,[[["self"]],["string"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"vzip","","",5,[[],["v"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,[[["self"],["t"]]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"type_id","","",12,[[["self"]],["typeid"]]],[11,"vzip","","",12,[[],["v"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"into","","",13,[[],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,[[["self"],["t"]]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"type_id","","",13,[[["self"]],["typeid"]]],[11,"vzip","","",13,[[],["v"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"into","","",14,[[],["u"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,[[["self"],["t"]]]],[11,"to_string","","",14,[[["self"]],["string"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"type_id","","",14,[[["self"]],["typeid"]]],[11,"vzip","","",14,[[],["v"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"into","","",15,[[],["u"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,[[["self"],["t"]]]],[11,"to_string","","",15,[[["self"]],["string"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"type_id","","",15,[[["self"]],["typeid"]]],[11,"vzip","","",15,[[],["v"]]],[11,"from","argmin::core::executor","",16,[[["t"]],["t"]]],[11,"into","","",16,[[],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,[[["self"],["t"]]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"type_id","","",16,[[["self"]],["typeid"]]],[11,"vzip","","",16,[[],["v"]]],[11,"from","argmin::prelude","",85,[[["t"]],["t"]]],[11,"into","","",85,[[],["u"]]],[11,"try_from","","",85,[[["u"]],["result"]]],[11,"try_into","","",85,[[],["result"]]],[11,"borrow","","",85,[[["self"]],["t"]]],[11,"borrow_mut","","",85,[[["self"]],["t"]]],[11,"type_id","","",85,[[["self"]],["typeid"]]],[11,"vzip","","",85,[[],["v"]]],[11,"from","","",86,[[["t"]],["t"]]],[11,"into","","",86,[[],["u"]]],[11,"to_string","","",86,[[["self"]],["string"]]],[11,"try_from","","",86,[[["u"]],["result"]]],[11,"try_into","","",86,[[],["result"]]],[11,"borrow","","",86,[[["self"]],["t"]]],[11,"borrow_mut","","",86,[[["self"]],["t"]]],[11,"type_id","","",86,[[["self"]],["typeid"]]],[11,"vzip","","",86,[[],["v"]]],[11,"from","argmin::solver::brent","",88,[[["t"]],["t"]]],[11,"into","","",88,[[],["u"]]],[11,"to_owned","","",88,[[["self"]],["t"]]],[11,"clone_into","","",88,[[["self"],["t"]]]],[11,"try_from","","",88,[[["u"]],["result"]]],[11,"try_into","","",88,[[],["result"]]],[11,"borrow","","",88,[[["self"]],["t"]]],[11,"borrow_mut","","",88,[[["self"]],["t"]]],[11,"type_id","","",88,[[["self"]],["typeid"]]],[11,"vzip","","",88,[[],["v"]]],[11,"from","","",87,[[["t"]],["t"]]],[11,"into","","",87,[[],["u"]]],[11,"to_string","","",87,[[["self"]],["string"]]],[11,"try_from","","",87,[[["u"]],["result"]]],[11,"try_into","","",87,[[],["result"]]],[11,"borrow","","",87,[[["self"]],["t"]]],[11,"borrow_mut","","",87,[[["self"]],["t"]]],[11,"type_id","","",87,[[["self"]],["typeid"]]],[11,"vzip","","",87,[[],["v"]]],[11,"from","argmin::solver::conjugategradient::cg","",89,[[["t"]],["t"]]],[11,"into","","",89,[[],["u"]]],[11,"to_owned","","",89,[[["self"]],["t"]]],[11,"clone_into","","",89,[[["self"],["t"]]]],[11,"try_from","","",89,[[["u"]],["result"]]],[11,"try_into","","",89,[[],["result"]]],[11,"borrow","","",89,[[["self"]],["t"]]],[11,"borrow_mut","","",89,[[["self"]],["t"]]],[11,"type_id","","",89,[[["self"]],["typeid"]]],[11,"vzip","","",89,[[],["v"]]],[11,"from","argmin::solver::conjugategradient::nonlinear_cg","",90,[[["t"]],["t"]]],[11,"into","","",90,[[],["u"]]],[11,"to_owned","","",90,[[["self"]],["t"]]],[11,"clone_into","","",90,[[["self"],["t"]]]],[11,"try_from","","",90,[[["u"]],["result"]]],[11,"try_into","","",90,[[],["result"]]],[11,"borrow","","",90,[[["self"]],["t"]]],[11,"borrow_mut","","",90,[[["self"]],["t"]]],[11,"type_id","","",90,[[["self"]],["typeid"]]],[11,"vzip","","",90,[[],["v"]]],[11,"from","argmin::solver::conjugategradient::beta","",91,[[["t"]],["t"]]],[11,"into","","",91,[[],["u"]]],[11,"to_owned","","",91,[[["self"]],["t"]]],[11,"clone_into","","",91,[[["self"],["t"]]]],[11,"try_from","","",91,[[["u"]],["result"]]],[11,"try_into","","",91,[[],["result"]]],[11,"borrow","","",91,[[["self"]],["t"]]],[11,"borrow_mut","","",91,[[["self"]],["t"]]],[11,"type_id","","",91,[[["self"]],["typeid"]]],[11,"vzip","","",91,[[],["v"]]],[11,"from","","",92,[[["t"]],["t"]]],[11,"into","","",92,[[],["u"]]],[11,"to_owned","","",92,[[["self"]],["t"]]],[11,"clone_into","","",92,[[["self"],["t"]]]],[11,"try_from","","",92,[[["u"]],["result"]]],[11,"try_into","","",92,[[],["result"]]],[11,"borrow","","",92,[[["self"]],["t"]]],[11,"borrow_mut","","",92,[[["self"]],["t"]]],[11,"type_id","","",92,[[["self"]],["typeid"]]],[11,"vzip","","",92,[[],["v"]]],[11,"from","","",93,[[["t"]],["t"]]],[11,"into","","",93,[[],["u"]]],[11,"to_owned","","",93,[[["self"]],["t"]]],[11,"clone_into","","",93,[[["self"],["t"]]]],[11,"try_from","","",93,[[["u"]],["result"]]],[11,"try_into","","",93,[[],["result"]]],[11,"borrow","","",93,[[["self"]],["t"]]],[11,"borrow_mut","","",93,[[["self"]],["t"]]],[11,"type_id","","",93,[[["self"]],["typeid"]]],[11,"vzip","","",93,[[],["v"]]],[11,"from","","",94,[[["t"]],["t"]]],[11,"into","","",94,[[],["u"]]],[11,"to_owned","","",94,[[["self"]],["t"]]],[11,"clone_into","","",94,[[["self"],["t"]]]],[11,"try_from","","",94,[[["u"]],["result"]]],[11,"try_into","","",94,[[],["result"]]],[11,"borrow","","",94,[[["self"]],["t"]]],[11,"borrow_mut","","",94,[[["self"]],["t"]]],[11,"type_id","","",94,[[["self"]],["typeid"]]],[11,"vzip","","",94,[[],["v"]]],[11,"from","argmin::solver::gaussnewton::gaussnewton_linesearch","",95,[[["t"]],["t"]]],[11,"into","","",95,[[],["u"]]],[11,"to_owned","","",95,[[["self"]],["t"]]],[11,"clone_into","","",95,[[["self"],["t"]]]],[11,"try_from","","",95,[[["u"]],["result"]]],[11,"try_into","","",95,[[],["result"]]],[11,"borrow","","",95,[[["self"]],["t"]]],[11,"borrow_mut","","",95,[[["self"]],["t"]]],[11,"type_id","","",95,[[["self"]],["typeid"]]],[11,"vzip","","",95,[[],["v"]]],[11,"from","argmin::solver::gaussnewton::gaussnewton_method","",96,[[["t"]],["t"]]],[11,"into","","",96,[[],["u"]]],[11,"to_owned","","",96,[[["self"]],["t"]]],[11,"clone_into","","",96,[[["self"],["t"]]]],[11,"try_from","","",96,[[["u"]],["result"]]],[11,"try_into","","",96,[[],["result"]]],[11,"borrow","","",96,[[["self"]],["t"]]],[11,"borrow_mut","","",96,[[["self"]],["t"]]],[11,"type_id","","",96,[[["self"]],["typeid"]]],[11,"vzip","","",96,[[],["v"]]],[11,"from","argmin::solver::goldensectionsearch","",97,[[["t"]],["t"]]],[11,"into","","",97,[[],["u"]]],[11,"to_owned","","",97,[[["self"]],["t"]]],[11,"clone_into","","",97,[[["self"],["t"]]]],[11,"try_from","","",97,[[["u"]],["result"]]],[11,"try_into","","",97,[[],["result"]]],[11,"borrow","","",97,[[["self"]],["t"]]],[11,"borrow_mut","","",97,[[["self"]],["t"]]],[11,"type_id","","",97,[[["self"]],["typeid"]]],[11,"vzip","","",97,[[],["v"]]],[11,"from","argmin::solver::gradientdescent::steepestdescent","",98,[[["t"]],["t"]]],[11,"into","","",98,[[],["u"]]],[11,"to_owned","","",98,[[["self"]],["t"]]],[11,"clone_into","","",98,[[["self"],["t"]]]],[11,"try_from","","",98,[[["u"]],["result"]]],[11,"try_into","","",98,[[],["result"]]],[11,"borrow","","",98,[[["self"]],["t"]]],[11,"borrow_mut","","",98,[[["self"]],["t"]]],[11,"type_id","","",98,[[["self"]],["typeid"]]],[11,"vzip","","",98,[[],["v"]]],[11,"from","argmin::solver::landweber","",99,[[["t"]],["t"]]],[11,"into","","",99,[[],["u"]]],[11,"to_owned","","",99,[[["self"]],["t"]]],[11,"clone_into","","",99,[[["self"],["t"]]]],[11,"try_from","","",99,[[["u"]],["result"]]],[11,"try_into","","",99,[[],["result"]]],[11,"borrow","","",99,[[["self"]],["t"]]],[11,"borrow_mut","","",99,[[["self"]],["t"]]],[11,"type_id","","",99,[[["self"]],["typeid"]]],[11,"vzip","","",99,[[],["v"]]],[11,"from","argmin::solver::linesearch::backtracking","",100,[[["t"]],["t"]]],[11,"into","","",100,[[],["u"]]],[11,"to_owned","","",100,[[["self"]],["t"]]],[11,"clone_into","","",100,[[["self"],["t"]]]],[11,"try_from","","",100,[[["u"]],["result"]]],[11,"try_into","","",100,[[],["result"]]],[11,"borrow","","",100,[[["self"]],["t"]]],[11,"borrow_mut","","",100,[[["self"]],["t"]]],[11,"type_id","","",100,[[["self"]],["typeid"]]],[11,"vzip","","",100,[[],["v"]]],[11,"from","argmin::solver::linesearch::condition","",102,[[["t"]],["t"]]],[11,"into","","",102,[[],["u"]]],[11,"to_owned","","",102,[[["self"]],["t"]]],[11,"clone_into","","",102,[[["self"],["t"]]]],[11,"try_from","","",102,[[["u"]],["result"]]],[11,"try_into","","",102,[[],["result"]]],[11,"borrow","","",102,[[["self"]],["t"]]],[11,"borrow_mut","","",102,[[["self"]],["t"]]],[11,"type_id","","",102,[[["self"]],["typeid"]]],[11,"vzip","","",102,[[],["v"]]],[11,"from","","",103,[[["t"]],["t"]]],[11,"into","","",103,[[],["u"]]],[11,"to_owned","","",103,[[["self"]],["t"]]],[11,"clone_into","","",103,[[["self"],["t"]]]],[11,"try_from","","",103,[[["u"]],["result"]]],[11,"try_into","","",103,[[],["result"]]],[11,"borrow","","",103,[[["self"]],["t"]]],[11,"borrow_mut","","",103,[[["self"]],["t"]]],[11,"type_id","","",103,[[["self"]],["typeid"]]],[11,"vzip","","",103,[[],["v"]]],[11,"from","","",104,[[["t"]],["t"]]],[11,"into","","",104,[[],["u"]]],[11,"to_owned","","",104,[[["self"]],["t"]]],[11,"clone_into","","",104,[[["self"],["t"]]]],[11,"try_from","","",104,[[["u"]],["result"]]],[11,"try_into","","",104,[[],["result"]]],[11,"borrow","","",104,[[["self"]],["t"]]],[11,"borrow_mut","","",104,[[["self"]],["t"]]],[11,"type_id","","",104,[[["self"]],["typeid"]]],[11,"vzip","","",104,[[],["v"]]],[11,"from","","",105,[[["t"]],["t"]]],[11,"into","","",105,[[],["u"]]],[11,"to_owned","","",105,[[["self"]],["t"]]],[11,"clone_into","","",105,[[["self"],["t"]]]],[11,"try_from","","",105,[[["u"]],["result"]]],[11,"try_into","","",105,[[],["result"]]],[11,"borrow","","",105,[[["self"]],["t"]]],[11,"borrow_mut","","",105,[[["self"]],["t"]]],[11,"type_id","","",105,[[["self"]],["typeid"]]],[11,"vzip","","",105,[[],["v"]]],[11,"from","argmin::solver::linesearch::hagerzhang","",106,[[["t"]],["t"]]],[11,"into","","",106,[[],["u"]]],[11,"to_owned","","",106,[[["self"]],["t"]]],[11,"clone_into","","",106,[[["self"],["t"]]]],[11,"try_from","","",106,[[["u"]],["result"]]],[11,"try_into","","",106,[[],["result"]]],[11,"borrow","","",106,[[["self"]],["t"]]],[11,"borrow_mut","","",106,[[["self"]],["t"]]],[11,"type_id","","",106,[[["self"]],["typeid"]]],[11,"vzip","","",106,[[],["v"]]],[11,"from","argmin::solver::linesearch::morethuente","",107,[[["t"]],["t"]]],[11,"into","","",107,[[],["u"]]],[11,"to_owned","","",107,[[["self"]],["t"]]],[11,"clone_into","","",107,[[["self"],["t"]]]],[11,"try_from","","",107,[[["u"]],["result"]]],[11,"try_into","","",107,[[],["result"]]],[11,"borrow","","",107,[[["self"]],["t"]]],[11,"borrow_mut","","",107,[[["self"]],["t"]]],[11,"type_id","","",107,[[["self"]],["typeid"]]],[11,"vzip","","",107,[[],["v"]]],[11,"from","argmin::solver::neldermead","",108,[[["t"]],["t"]]],[11,"into","","",108,[[],["u"]]],[11,"to_owned","","",108,[[["self"]],["t"]]],[11,"clone_into","","",108,[[["self"],["t"]]]],[11,"try_from","","",108,[[["u"]],["result"]]],[11,"try_into","","",108,[[],["result"]]],[11,"borrow","","",108,[[["self"]],["t"]]],[11,"borrow_mut","","",108,[[["self"]],["t"]]],[11,"type_id","","",108,[[["self"]],["typeid"]]],[11,"vzip","","",108,[[],["v"]]],[11,"from","argmin::solver::newton::newton_cg","",109,[[["t"]],["t"]]],[11,"into","","",109,[[],["u"]]],[11,"to_owned","","",109,[[["self"]],["t"]]],[11,"clone_into","","",109,[[["self"],["t"]]]],[11,"try_from","","",109,[[["u"]],["result"]]],[11,"try_into","","",109,[[],["result"]]],[11,"borrow","","",109,[[["self"]],["t"]]],[11,"borrow_mut","","",109,[[["self"]],["t"]]],[11,"type_id","","",109,[[["self"]],["typeid"]]],[11,"vzip","","",109,[[],["v"]]],[11,"from","argmin::solver::newton::newton_method","",110,[[["t"]],["t"]]],[11,"into","","",110,[[],["u"]]],[11,"to_owned","","",110,[[["self"]],["t"]]],[11,"clone_into","","",110,[[["self"],["t"]]]],[11,"try_from","","",110,[[["u"]],["result"]]],[11,"try_into","","",110,[[],["result"]]],[11,"borrow","","",110,[[["self"]],["t"]]],[11,"borrow_mut","","",110,[[["self"]],["t"]]],[11,"type_id","","",110,[[["self"]],["typeid"]]],[11,"vzip","","",110,[[],["v"]]],[11,"from","argmin::solver::particleswarm","",112,[[["t"]],["t"]]],[11,"into","","",112,[[],["u"]]],[11,"try_from","","",112,[[["u"]],["result"]]],[11,"try_into","","",112,[[],["result"]]],[11,"borrow","","",112,[[["self"]],["t"]]],[11,"borrow_mut","","",112,[[["self"]],["t"]]],[11,"type_id","","",112,[[["self"]],["typeid"]]],[11,"vzip","","",112,[[],["v"]]],[11,"from","","",111,[[["t"]],["t"]]],[11,"into","","",111,[[],["u"]]],[11,"to_owned","","",111,[[["self"]],["t"]]],[11,"clone_into","","",111,[[["self"],["t"]]]],[11,"try_from","","",111,[[["u"]],["result"]]],[11,"try_into","","",111,[[],["result"]]],[11,"borrow","","",111,[[["self"]],["t"]]],[11,"borrow_mut","","",111,[[["self"]],["t"]]],[11,"type_id","","",111,[[["self"]],["typeid"]]],[11,"vzip","","",111,[[],["v"]]],[11,"from","argmin::solver::quasinewton::bfgs","",113,[[["t"]],["t"]]],[11,"into","","",113,[[],["u"]]],[11,"to_owned","","",113,[[["self"]],["t"]]],[11,"clone_into","","",113,[[["self"],["t"]]]],[11,"try_from","","",113,[[["u"]],["result"]]],[11,"try_into","","",113,[[],["result"]]],[11,"borrow","","",113,[[["self"]],["t"]]],[11,"borrow_mut","","",113,[[["self"]],["t"]]],[11,"type_id","","",113,[[["self"]],["typeid"]]],[11,"vzip","","",113,[[],["v"]]],[11,"from","argmin::solver::quasinewton::dfp","",114,[[["t"]],["t"]]],[11,"into","","",114,[[],["u"]]],[11,"to_owned","","",114,[[["self"]],["t"]]],[11,"clone_into","","",114,[[["self"],["t"]]]],[11,"try_from","","",114,[[["u"]],["result"]]],[11,"try_into","","",114,[[],["result"]]],[11,"borrow","","",114,[[["self"]],["t"]]],[11,"borrow_mut","","",114,[[["self"]],["t"]]],[11,"type_id","","",114,[[["self"]],["typeid"]]],[11,"vzip","","",114,[[],["v"]]],[11,"from","argmin::solver::quasinewton::lbfgs","",115,[[["t"]],["t"]]],[11,"into","","",115,[[],["u"]]],[11,"to_owned","","",115,[[["self"]],["t"]]],[11,"clone_into","","",115,[[["self"],["t"]]]],[11,"try_from","","",115,[[["u"]],["result"]]],[11,"try_into","","",115,[[],["result"]]],[11,"borrow","","",115,[[["self"]],["t"]]],[11,"borrow_mut","","",115,[[["self"]],["t"]]],[11,"type_id","","",115,[[["self"]],["typeid"]]],[11,"vzip","","",115,[[],["v"]]],[11,"from","argmin::solver::quasinewton::sr1","",116,[[["t"]],["t"]]],[11,"into","","",116,[[],["u"]]],[11,"to_owned","","",116,[[["self"]],["t"]]],[11,"clone_into","","",116,[[["self"],["t"]]]],[11,"try_from","","",116,[[["u"]],["result"]]],[11,"try_into","","",116,[[],["result"]]],[11,"borrow","","",116,[[["self"]],["t"]]],[11,"borrow_mut","","",116,[[["self"]],["t"]]],[11,"type_id","","",116,[[["self"]],["typeid"]]],[11,"vzip","","",116,[[],["v"]]],[11,"from","argmin::solver::quasinewton::sr1_trustregion","",117,[[["t"]],["t"]]],[11,"into","","",117,[[],["u"]]],[11,"to_owned","","",117,[[["self"]],["t"]]],[11,"clone_into","","",117,[[["self"],["t"]]]],[11,"try_from","","",117,[[["u"]],["result"]]],[11,"try_into","","",117,[[],["result"]]],[11,"borrow","","",117,[[["self"]],["t"]]],[11,"borrow_mut","","",117,[[["self"]],["t"]]],[11,"type_id","","",117,[[["self"]],["typeid"]]],[11,"vzip","","",117,[[],["v"]]],[11,"from","argmin::solver::simulatedannealing","",119,[[["t"]],["t"]]],[11,"into","","",119,[[],["u"]]],[11,"to_owned","","",119,[[["self"]],["t"]]],[11,"clone_into","","",119,[[["self"],["t"]]]],[11,"try_from","","",119,[[["u"]],["result"]]],[11,"try_into","","",119,[[],["result"]]],[11,"borrow","","",119,[[["self"]],["t"]]],[11,"borrow_mut","","",119,[[["self"]],["t"]]],[11,"type_id","","",119,[[["self"]],["typeid"]]],[11,"vzip","","",119,[[],["v"]]],[11,"from","","",118,[[["t"]],["t"]]],[11,"into","","",118,[[],["u"]]],[11,"to_owned","","",118,[[["self"]],["t"]]],[11,"clone_into","","",118,[[["self"],["t"]]]],[11,"try_from","","",118,[[["u"]],["result"]]],[11,"try_into","","",118,[[],["result"]]],[11,"borrow","","",118,[[["self"]],["t"]]],[11,"borrow_mut","","",118,[[["self"]],["t"]]],[11,"type_id","","",118,[[["self"]],["typeid"]]],[11,"vzip","","",118,[[],["v"]]],[11,"from","argmin::solver::trustregion::cauchypoint","",120,[[["t"]],["t"]]],[11,"into","","",120,[[],["u"]]],[11,"to_owned","","",120,[[["self"]],["t"]]],[11,"clone_into","","",120,[[["self"],["t"]]]],[11,"try_from","","",120,[[["u"]],["result"]]],[11,"try_into","","",120,[[],["result"]]],[11,"borrow","","",120,[[["self"]],["t"]]],[11,"borrow_mut","","",120,[[["self"]],["t"]]],[11,"type_id","","",120,[[["self"]],["typeid"]]],[11,"vzip","","",120,[[],["v"]]],[11,"from","argmin::solver::trustregion::dogleg","",121,[[["t"]],["t"]]],[11,"into","","",121,[[],["u"]]],[11,"to_owned","","",121,[[["self"]],["t"]]],[11,"clone_into","","",121,[[["self"],["t"]]]],[11,"try_from","","",121,[[["u"]],["result"]]],[11,"try_into","","",121,[[],["result"]]],[11,"borrow","","",121,[[["self"]],["t"]]],[11,"borrow_mut","","",121,[[["self"]],["t"]]],[11,"type_id","","",121,[[["self"]],["typeid"]]],[11,"vzip","","",121,[[],["v"]]],[11,"from","argmin::solver::trustregion::steihaug","",122,[[["t"]],["t"]]],[11,"into","","",122,[[],["u"]]],[11,"to_owned","","",122,[[["self"]],["t"]]],[11,"clone_into","","",122,[[["self"],["t"]]]],[11,"try_from","","",122,[[["u"]],["result"]]],[11,"try_into","","",122,[[],["result"]]],[11,"borrow","","",122,[[["self"]],["t"]]],[11,"borrow_mut","","",122,[[["self"]],["t"]]],[11,"type_id","","",122,[[["self"]],["typeid"]]],[11,"vzip","","",122,[[],["v"]]],[11,"from","argmin::solver::trustregion::trustregion_method","",123,[[["t"]],["t"]]],[11,"into","","",123,[[],["u"]]],[11,"to_owned","","",123,[[["self"]],["t"]]],[11,"clone_into","","",123,[[["self"],["t"]]]],[11,"try_from","","",123,[[["u"]],["result"]]],[11,"try_into","","",123,[[],["result"]]],[11,"borrow","","",123,[[["self"]],["t"]]],[11,"borrow_mut","","",123,[[["self"]],["t"]]],[11,"type_id","","",123,[[["self"]],["typeid"]]],[11,"vzip","","",123,[[],["v"]]],[11,"fmt","argmin::prelude","",86,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",86,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",85,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","argmin::core","",124,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"drop","","",124,[[["self"]]]],[11,"deref_mut","","",124,[[["self"]]]],[11,"fmt","","",124,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"from","","",124,[[["e"]],["error"]]],[11,"deref","","",124,[[["self"]]]],[11,"as_ref","","",124,[[["self"]],["error"]]],[11,"as_ref","","",124,[[["self"]],["error"]]],[11,"observe_iter","","",19,[[["argminkv"],["self"],["iterstate"]],[["result",["error"]],["error"]]]],[11,"observe_init","","Log general info",20,[[["str"],["argminkv"],["self"]],[["result",["error"]],["error"]]]],[11,"observe_iter","","This should be used to log iteration data only (because…",20,[[["argminkv"],["self"],["iterstate"]],[["result",["error"]],["error"]]]],[11,"observe_iter","","",21,[[["argminkv"],["self"],["iterstate"]],[["result",["error"]],["error"]]]],[11,"observe_init","","Initial observation This is called after the…",23,[[["str"],["argminkv"],["self"]],[["result",["error"]],["error"]]]],[11,"observe_iter","","This is called after every iteration and gets the current…",23,[[["argminkv"],["self"],["iterstate"]],[["result",["error"]],["error"]]]],[11,"apply","","Do nothing, really.",17,[[["self"]],[["error"],["result",["error"]]]]],[11,"gradient","","Do nothing, really.",17,[[["self"]],[["error"],["result",["error"]]]]],[11,"hessian","","Do nothing, really.",17,[[["self"]],[["result",["error"]],["error"]]]],[11,"modify","","Do nothing, really.",17,[[["self"]],[["error"],["result",["error"]]]]],[11,"apply","","Do nothing, really.",18,[[["self"]],[["error"],["result",["error"]]]]],[11,"gradient","","Do nothing, really.",18,[[["self"]],[["error"],["result",["error"]]]]],[11,"hessian","","Do nothing, really.",18,[[["self"]],[["result",["error"]],["error"]]]],[11,"modify","","Do nothing, really.",18,[[["self"],["f64"]],[["error"],["result",["error"]]]]],[11,"apply","","",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"gradient","","",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"hessian","","",3,[[["self"]],[["result",["error"]],["error"]]]],[11,"jacobian","","",3,[[["self"]],[["result",["error"]],["error"]]]],[11,"modify","","",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"init","argmin::solver::brent","",88,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",88,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"init","argmin::solver::conjugategradient::cg","",89,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","Perform one iteration of CG algorithm",89,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"init","argmin::solver::conjugategradient::nonlinear_cg","",90,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",90,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"next_iter","argmin::solver::gaussnewton::gaussnewton_linesearch","",95,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",95,[[["self"],["iterstate"]],["terminationreason"]]],[11,"next_iter","argmin::solver::gaussnewton::gaussnewton_method","",96,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",96,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::goldensectionsearch","",97,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",97,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"next_iter","argmin::solver::gradientdescent::steepestdescent","",98,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"next_iter","argmin::solver::landweber","",99,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"init","argmin::solver::linesearch::backtracking","",100,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",100,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",100,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::linesearch::hagerzhang","",106,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",106,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",106,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::linesearch::morethuente","",107,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",107,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"init","argmin::solver::neldermead","",108,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",108,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",108,[[["self"],["iterstate"]],["terminationreason"]]],[11,"next_iter","argmin::solver::newton::newton_cg","",109,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",109,[[["self"],["iterstate"]],["terminationreason"]]],[11,"next_iter","argmin::solver::newton::newton_method","",110,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"init","argmin::solver::particleswarm","",112,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","Perform one iteration of algorithm",112,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"init","argmin::solver::quasinewton::bfgs","",113,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",113,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",113,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::quasinewton::dfp","",114,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",114,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",114,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::quasinewton::lbfgs","",115,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",115,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",115,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::quasinewton::sr1","",116,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",116,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",116,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::quasinewton::sr1_trustregion","",117,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",117,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",117,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::simulatedannealing","",119,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","Perform one iteration of SA algorithm",119,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",119,[[["self"],["iterstate"]],["terminationreason"]]],[11,"next_iter","argmin::solver::trustregion::cauchypoint","",120,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",120,[[["self"],["iterstate"]],["terminationreason"]]],[11,"next_iter","argmin::solver::trustregion::dogleg","",121,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",121,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::trustregion::steihaug","",122,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",122,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",122,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::trustregion::trustregion_method","",123,[[["self"],["opwrapper"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",123,[[["self"],["opwrapper"],["iterstate"]],[["result",["argminiterdata","error"]],["argminiterdata"],["error"]]]],[11,"terminate","","",123,[[["self"],["iterstate"]],["terminationreason"]]],[11,"set_search_direction","argmin::solver::linesearch::backtracking","Set search direction",100,[[["self"],["p"]]]],[11,"set_init_alpha","","Set initial alpha value",100,[[["self"],["f"]],[["result",["error"]],["error"]]]],[11,"set_search_direction","argmin::solver::linesearch::hagerzhang","Set search direction",106,[[["self"],["p"]]]],[11,"set_init_alpha","","Set initial alpha value",106,[[["self"],["f"]],[["result",["error"]],["error"]]]],[11,"set_search_direction","argmin::solver::linesearch::morethuente","Set search direction",107,[[["self"],["p"]]]],[11,"set_init_alpha","","Set initial alpha value",107,[[["self"],["f"]],[["result",["error"]],["error"]]]],[11,"set_radius","argmin::solver::trustregion::cauchypoint","",120,[[["self"],["f"]]]],[11,"set_radius","argmin::solver::trustregion::dogleg","",121,[[["self"],["f"]]]],[11,"set_radius","argmin::solver::trustregion::steihaug","",122,[[["self"],["f"]]]],[11,"update","argmin::solver::conjugategradient::beta","",91,[[["t"],["self"]],["f"]]],[11,"update","","",92,[[["t"],["self"]],["f"]]],[11,"update","","",93,[[["t"],["self"]],["f"]]],[11,"update","","",94,[[["t"],["self"]],["f"]]],[11,"eval","argmin::solver::linesearch::condition","",102,[[["t"],["self"],["f"]],["bool"]]],[11,"requires_cur_grad","","",102,[[["self"]],["bool"]]],[11,"eval","","",103,[[["t"],["self"],["f"]],["bool"]]],[11,"requires_cur_grad","","",103,[[["self"]],["bool"]]],[11,"eval","","",104,[[["t"],["self"],["f"]],["bool"]]],[11,"requires_cur_grad","","",104,[[["self"]],["bool"]]],[11,"eval","","",105,[[["t"],["self"],["f"]],["bool"]]],[11,"requires_cur_grad","","",105,[[["self"]],["bool"]]],[11,"from","argmin::core","",2,[[["argminkv"]],["argminslogkv"]]],[11,"extend","","",1,[[["intoiterator"],["self"]]]],[11,"clone","argmin::core::executor","",16,[[["self"]],["executor"]]],[11,"clone","argmin::core","",0,[[["self"]],["iterstate"]]],[11,"clone","","",1,[[["self"]],["argminkv"]]],[11,"clone","","",17,[[["self"]],["nooperator"]]],[11,"clone","","",18,[[["self"]],["minimalnooperator"]]],[11,"clone","","",12,[[["self"]],["writetofileserializer"]]],[11,"clone","","",19,[[["self"]],["writetofile"]]],[11,"clone","","",20,[[["self"]],["argminsloglogger"]]],[11,"clone","","",23,[[["self"]],["observer"]]],[11,"clone","","",13,[[["self"]],["observermode"]]],[11,"clone","","",3,[[["self"]],["opwrapper"]]],[11,"clone","","",4,[[["self"]],["argminresult"]]],[11,"clone","","",14,[[["self"]],["checkpointmode"]]],[11,"clone","","",24,[[["self"]],["argmincheckpoint"]]],[11,"clone","","",15,[[["self"]],["terminationreason"]]],[11,"clone","","",48,[[["self"]],["argminiterdata"]]],[11,"clone","argmin::solver::brent","",88,[[["self"]],["brent"]]],[11,"clone","argmin::solver::conjugategradient::cg","",89,[[["self"]],["conjugategradient"]]],[11,"clone","argmin::solver::conjugategradient::nonlinear_cg","",90,[[["self"]],["nonlinearconjugategradient"]]],[11,"clone","argmin::solver::conjugategradient::beta","",91,[[["self"]],["fletcherreeves"]]],[11,"clone","","",92,[[["self"]],["polakribiere"]]],[11,"clone","","",93,[[["self"]],["polakribiereplus"]]],[11,"clone","","",94,[[["self"]],["hestenesstiefel"]]],[11,"clone","argmin::solver::gaussnewton::gaussnewton_linesearch","",95,[[["self"]],["gaussnewtonls"]]],[11,"clone","argmin::solver::gaussnewton::gaussnewton_method","",96,[[["self"]],["gaussnewton"]]],[11,"clone","argmin::solver::goldensectionsearch","",97,[[["self"]],["goldensectionsearch"]]],[11,"clone","argmin::solver::gradientdescent::steepestdescent","",98,[[["self"]],["steepestdescent"]]],[11,"clone","argmin::solver::landweber","",99,[[["self"]],["landweber"]]],[11,"clone","argmin::solver::linesearch::backtracking","",100,[[["self"]],["backtrackinglinesearch"]]],[11,"clone","argmin::solver::linesearch::condition","",102,[[["self"]],["armijocondition"]]],[11,"clone","","",103,[[["self"]],["wolfecondition"]]],[11,"clone","","",104,[[["self"]],["strongwolfecondition"]]],[11,"clone","","",105,[[["self"]],["goldsteincondition"]]],[11,"clone","argmin::solver::linesearch::hagerzhang","",106,[[["self"]],["hagerzhanglinesearch"]]],[11,"clone","argmin::solver::linesearch::morethuente","",107,[[["self"]],["morethuentelinesearch"]]],[11,"clone","argmin::solver::neldermead","",108,[[["self"]],["neldermead"]]],[11,"clone","argmin::solver::newton::newton_cg","",109,[[["self"]],["newtoncg"]]],[11,"clone","argmin::solver::newton::newton_method","",110,[[["self"]],["newton"]]],[11,"clone","argmin::solver::particleswarm","",111,[[["self"]],["particle"]]],[11,"clone","argmin::solver::quasinewton::bfgs","",113,[[["self"]],["bfgs"]]],[11,"clone","argmin::solver::quasinewton::dfp","",114,[[["self"]],["dfp"]]],[11,"clone","argmin::solver::quasinewton::lbfgs","",115,[[["self"]],["lbfgs"]]],[11,"clone","argmin::solver::quasinewton::sr1","",116,[[["self"]],["sr1"]]],[11,"clone","argmin::solver::quasinewton::sr1_trustregion","",117,[[["self"]],["sr1trustregion"]]],[11,"clone","argmin::solver::simulatedannealing","",118,[[["self"]],["satempfunc"]]],[11,"clone","","",119,[[["self"]],["simulatedannealing"]]],[11,"clone","argmin::solver::trustregion::cauchypoint","",120,[[["self"]],["cauchypoint"]]],[11,"clone","argmin::solver::trustregion::dogleg","",121,[[["self"]],["dogleg"]]],[11,"clone","argmin::solver::trustregion::steihaug","",122,[[["self"]],["steihaug"]]],[11,"clone","argmin::solver::trustregion::trustregion_method","",123,[[["self"]],["trustregion"]]],[11,"default","argmin::core","",0,[[],["self"]]],[11,"default","","",1,[[],["argminkv"]]],[11,"default","","",17,[[],["nooperator"]]],[11,"default","","",18,[[],["minimalnooperator"]]],[11,"default","","",12,[[],["self"]]],[11,"default","","",23,[[],["observer"]]],[11,"default","","The default is `Always`",13,[[],["observermode"]]],[11,"default","","",3,[[],["opwrapper"]]],[11,"default","","",14,[[],["checkpointmode"]]],[11,"default","","",24,[[],["argmincheckpoint"]]],[11,"default","","",15,[[],["self"]]],[11,"default","","",48,[[],["argminiterdata"]]],[11,"default","argmin::solver::conjugategradient::beta","",91,[[],["fletcherreeves"]]],[11,"default","","",92,[[],["polakribiere"]]],[11,"default","","",93,[[],["polakribiereplus"]]],[11,"default","","",94,[[],["hestenesstiefel"]]],[11,"default","argmin::solver::gaussnewton::gaussnewton_method","",96,[[],["gaussnewton"]]],[11,"default","argmin::solver::linesearch::condition","",102,[[],["armijocondition"]]],[11,"default","","",103,[[],["wolfecondition"]]],[11,"default","","",104,[[],["strongwolfecondition"]]],[11,"default","","",105,[[],["goldsteincondition"]]],[11,"default","argmin::solver::linesearch::hagerzhang","",106,[[],["self"]]],[11,"default","argmin::solver::linesearch::morethuente","",107,[[],["self"]]],[11,"default","argmin::solver::neldermead","",108,[[],["neldermead"]]],[11,"default","argmin::solver::newton::newton_method","",110,[[],["newton"]]],[11,"default","argmin::solver::simulatedannealing","",118,[[],["self"]]],[11,"default","argmin::solver::trustregion::cauchypoint","",120,[[],["cauchypoint"]]],[11,"default","argmin::solver::trustregion::dogleg","",121,[[],["dogleg"]]],[11,"default","argmin::solver::trustregion::steihaug","",122,[[],["steihaug"]]],[11,"cmp","argmin::core","",1,[[["argminkv"],["self"]],["ordering"]]],[11,"cmp","","",17,[[["nooperator"],["self"]],["ordering"]]],[11,"cmp","","",18,[[["minimalnooperator"],["self"]],["ordering"]]],[11,"cmp","","",12,[[["writetofileserializer"],["self"]],["ordering"]]],[11,"cmp","","",19,[[["self"],["writetofile"]],["ordering"]]],[11,"cmp","","",13,[[["observermode"],["self"]],["ordering"]]],[11,"cmp","","",4,[[["argminresult"],["self"]],["ordering"]]],[11,"cmp","","",14,[[["checkpointmode"],["self"]],["ordering"]]],[11,"cmp","","",24,[[["argmincheckpoint"],["self"]],["ordering"]]],[11,"cmp","","",15,[[["self"],["terminationreason"]],["ordering"]]],[11,"cmp","argmin::solver::conjugategradient::beta","",91,[[["self"],["fletcherreeves"]],["ordering"]]],[11,"cmp","","",92,[[["self"],["polakribiere"]],["ordering"]]],[11,"cmp","","",93,[[["self"],["polakribiereplus"]],["ordering"]]],[11,"cmp","","",94,[[["hestenesstiefel"],["self"]],["ordering"]]],[11,"eq","argmin::core","",1,[[["argminkv"],["self"]],["bool"]]],[11,"ne","","",1,[[["argminkv"],["self"]],["bool"]]],[11,"eq","","",17,[[["nooperator"],["self"]],["bool"]]],[11,"ne","","",17,[[["nooperator"],["self"]],["bool"]]],[11,"eq","","",18,[[["minimalnooperator"],["self"]],["bool"]]],[11,"eq","","",12,[[["writetofileserializer"],["self"]],["bool"]]],[11,"eq","","",19,[[["self"],["writetofile"]],["bool"]]],[11,"ne","","",19,[[["self"],["writetofile"]],["bool"]]],[11,"eq","","",13,[[["observermode"],["self"]],["bool"]]],[11,"ne","","",13,[[["observermode"],["self"]],["bool"]]],[11,"eq","","",4,[[["argminresult"],["self"]],["bool"]]],[11,"eq","","",14,[[["checkpointmode"],["self"]],["bool"]]],[11,"ne","","",14,[[["checkpointmode"],["self"]],["bool"]]],[11,"eq","","",24,[[["argmincheckpoint"],["self"]],["bool"]]],[11,"ne","","",24,[[["argmincheckpoint"],["self"]],["bool"]]],[11,"eq","","",15,[[["self"],["terminationreason"]],["bool"]]],[11,"eq","argmin::solver::conjugategradient::beta","",91,[[["self"],["fletcherreeves"]],["bool"]]],[11,"eq","","",92,[[["self"],["polakribiere"]],["bool"]]],[11,"eq","","",93,[[["self"],["polakribiereplus"]],["bool"]]],[11,"eq","","",94,[[["hestenesstiefel"],["self"]],["bool"]]],[11,"eq","argmin::solver::trustregion::cauchypoint","",120,[[["self"],["cauchypoint"]],["bool"]]],[11,"ne","","",120,[[["self"],["cauchypoint"]],["bool"]]],[11,"eq","argmin::solver::trustregion::dogleg","",121,[[["self"],["dogleg"]],["bool"]]],[11,"ne","","",121,[[["self"],["dogleg"]],["bool"]]],[11,"eq","argmin::solver::trustregion::steihaug","",122,[[["self"],["steihaug"]],["bool"]]],[11,"ne","","",122,[[["self"],["steihaug"]],["bool"]]],[11,"partial_cmp","argmin::core","",1,[[["argminkv"],["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",1,[[["argminkv"],["self"]],["bool"]]],[11,"le","","",1,[[["argminkv"],["self"]],["bool"]]],[11,"gt","","",1,[[["argminkv"],["self"]],["bool"]]],[11,"ge","","",1,[[["argminkv"],["self"]],["bool"]]],[11,"partial_cmp","","",17,[[["nooperator"],["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",17,[[["nooperator"],["self"]],["bool"]]],[11,"le","","",17,[[["nooperator"],["self"]],["bool"]]],[11,"gt","","",17,[[["nooperator"],["self"]],["bool"]]],[11,"ge","","",17,[[["nooperator"],["self"]],["bool"]]],[11,"partial_cmp","","",18,[[["minimalnooperator"],["self"]],[["option",["ordering"]],["ordering"]]]],[11,"partial_cmp","","",12,[[["writetofileserializer"],["self"]],[["option",["ordering"]],["ordering"]]]],[11,"partial_cmp","","",19,[[["self"],["writetofile"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",19,[[["self"],["writetofile"]],["bool"]]],[11,"le","","",19,[[["self"],["writetofile"]],["bool"]]],[11,"gt","","",19,[[["self"],["writetofile"]],["bool"]]],[11,"ge","","",19,[[["self"],["writetofile"]],["bool"]]],[11,"partial_cmp","","",13,[[["observermode"],["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",13,[[["observermode"],["self"]],["bool"]]],[11,"le","","",13,[[["observermode"],["self"]],["bool"]]],[11,"gt","","",13,[[["observermode"],["self"]],["bool"]]],[11,"ge","","",13,[[["observermode"],["self"]],["bool"]]],[11,"partial_cmp","","",4,[[["argminresult"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","","",14,[[["checkpointmode"],["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["checkpointmode"],["self"]],["bool"]]],[11,"le","","",14,[[["checkpointmode"],["self"]],["bool"]]],[11,"gt","","",14,[[["checkpointmode"],["self"]],["bool"]]],[11,"ge","","",14,[[["checkpointmode"],["self"]],["bool"]]],[11,"partial_cmp","","",24,[[["argmincheckpoint"],["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",24,[[["argmincheckpoint"],["self"]],["bool"]]],[11,"le","","",24,[[["argmincheckpoint"],["self"]],["bool"]]],[11,"gt","","",24,[[["argmincheckpoint"],["self"]],["bool"]]],[11,"ge","","",24,[[["argmincheckpoint"],["self"]],["bool"]]],[11,"partial_cmp","","",15,[[["self"],["terminationreason"]],[["option",["ordering"]],["ordering"]]]],[11,"partial_cmp","argmin::solver::conjugategradient::beta","",91,[[["self"],["fletcherreeves"]],[["option",["ordering"]],["ordering"]]]],[11,"partial_cmp","","",92,[[["self"],["polakribiere"]],[["option",["ordering"]],["ordering"]]]],[11,"partial_cmp","","",93,[[["self"],["polakribiereplus"]],[["option",["ordering"]],["ordering"]]]],[11,"partial_cmp","","",94,[[["hestenesstiefel"],["self"]],[["option",["ordering"]],["ordering"]]]],[11,"partial_cmp","argmin::solver::trustregion::cauchypoint","",120,[[["self"],["cauchypoint"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",120,[[["self"],["cauchypoint"]],["bool"]]],[11,"le","","",120,[[["self"],["cauchypoint"]],["bool"]]],[11,"gt","","",120,[[["self"],["cauchypoint"]],["bool"]]],[11,"ge","","",120,[[["self"],["cauchypoint"]],["bool"]]],[11,"partial_cmp","argmin::solver::trustregion::dogleg","",121,[[["self"],["dogleg"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",121,[[["self"],["dogleg"]],["bool"]]],[11,"le","","",121,[[["self"],["dogleg"]],["bool"]]],[11,"gt","","",121,[[["self"],["dogleg"]],["bool"]]],[11,"ge","","",121,[[["self"],["dogleg"]],["bool"]]],[11,"partial_cmp","argmin::solver::trustregion::steihaug","",122,[[["self"],["steihaug"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",122,[[["self"],["steihaug"]],["bool"]]],[11,"le","","",122,[[["self"],["steihaug"]],["bool"]]],[11,"gt","","",122,[[["self"],["steihaug"]],["bool"]]],[11,"ge","","",122,[[["self"],["steihaug"]],["bool"]]],[11,"fmt","argmin::core","",5,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",17,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",18,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",12,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",19,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",13,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",3,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",14,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",24,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",15,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",48,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::brent","",87,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::conjugategradient::beta","",91,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",92,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",93,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",94,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::linesearch::condition","",102,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",103,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",104,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",105,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::particleswarm","",111,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::simulatedannealing","",118,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::trustregion::cauchypoint","",120,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::trustregion::dogleg","",121,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::trustregion::steihaug","",122,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::core","",5,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",17,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",18,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",4,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",14,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",15,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::brent","",87,[[["formatter"],["self"]],["result"]]],[11,"hash","argmin::core","",1,[[["self"],["__h"]]]],[11,"hash","","",17,[[["self"],["__h"]]]],[11,"hash","","",18,[[["self"],["__h"]]]],[11,"hash","","",14,[[["self"],["__h"]]]],[11,"hash","","",24,[[["self"],["__h"]]]],[11,"hash","","",15,[[["self"],["__h"]]]],[11,"hash","argmin::solver::conjugategradient::beta","",91,[[["self"],["__h"]]]],[11,"hash","","",92,[[["self"],["__h"]]]],[11,"hash","","",93,[[["self"],["__h"]]]],[11,"hash","","",94,[[["self"],["__h"]]]],[11,"from_iter","argmin::core","",1,[[["intoiterator"]],["self"]]],[11,"serialize","argmin::core::executor","",16,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::core","",0,[[["self"],["__s"]],["result"]]],[11,"serialize","","",1,[[["self"],["__s"]],["result"]]],[11,"serialize","","",17,[[["self"],["__s"]],["result"]]],[11,"serialize","","",18,[[["self"],["__s"]],["result"]]],[11,"serialize","","",12,[[["self"],["__s"]],["result"]]],[11,"serialize","","",19,[[["self"],["__s"]],["result"]]],[11,"serialize","","",13,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"serialize","","",14,[[["self"],["__s"]],["result"]]],[11,"serialize","","",24,[[["self"],["__s"]],["result"]]],[11,"serialize","","",15,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::brent","",88,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::conjugategradient::cg","",89,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::conjugategradient::nonlinear_cg","",90,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::conjugategradient::beta","",91,[[["self"],["__s"]],["result"]]],[11,"serialize","","",92,[[["self"],["__s"]],["result"]]],[11,"serialize","","",93,[[["self"],["__s"]],["result"]]],[11,"serialize","","",94,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::gaussnewton::gaussnewton_linesearch","",95,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::gaussnewton::gaussnewton_method","",96,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::goldensectionsearch","",97,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::gradientdescent::steepestdescent","",98,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::landweber","",99,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::linesearch::backtracking","",100,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::linesearch::condition","",102,[[["self"],["__s"]],["result"]]],[11,"serialize","","",103,[[["self"],["__s"]],["result"]]],[11,"serialize","","",104,[[["self"],["__s"]],["result"]]],[11,"serialize","","",105,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::linesearch::hagerzhang","",106,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::linesearch::morethuente","",107,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::neldermead","",108,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::newton::newton_cg","",109,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::newton::newton_method","",110,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::particleswarm","",112,[[["self"],["__s"]],["result"]]],[11,"serialize","","",111,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::quasinewton::bfgs","",113,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::quasinewton::dfp","",114,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::quasinewton::lbfgs","",115,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::quasinewton::sr1","",116,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::quasinewton::sr1_trustregion","",117,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::simulatedannealing","",118,[[["self"],["__s"]],["result"]]],[11,"serialize","","",119,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::trustregion::cauchypoint","",120,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::trustregion::dogleg","",121,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::trustregion::steihaug","",122,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::trustregion::trustregion_method","",123,[[["self"],["__s"]],["result"]]],[11,"deserialize","argmin::core::executor","",16,[[["__d"]],["result"]]],[11,"deserialize","argmin::core","",0,[[["__d"]],["result"]]],[11,"deserialize","","",1,[[["__d"]],["result"]]],[11,"deserialize","","",17,[[["__d"]],["result"]]],[11,"deserialize","","",18,[[["__d"]],["result"]]],[11,"deserialize","","",12,[[["__d"]],["result"]]],[11,"deserialize","","",19,[[["__d"]],["result"]]],[11,"deserialize","","",13,[[["__d"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result"]]],[11,"deserialize","","",14,[[["__d"]],["result"]]],[11,"deserialize","","",24,[[["__d"]],["result"]]],[11,"deserialize","","",15,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::brent","",88,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::conjugategradient::cg","",89,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::conjugategradient::nonlinear_cg","",90,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::conjugategradient::beta","",91,[[["__d"]],["result"]]],[11,"deserialize","","",92,[[["__d"]],["result"]]],[11,"deserialize","","",93,[[["__d"]],["result"]]],[11,"deserialize","","",94,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::gaussnewton::gaussnewton_linesearch","",95,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::gaussnewton::gaussnewton_method","",96,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::goldensectionsearch","",97,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::gradientdescent::steepestdescent","",98,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::landweber","",99,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::linesearch::backtracking","",100,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::linesearch::condition","",102,[[["__d"]],["result"]]],[11,"deserialize","","",103,[[["__d"]],["result"]]],[11,"deserialize","","",104,[[["__d"]],["result"]]],[11,"deserialize","","",105,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::linesearch::hagerzhang","",106,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::linesearch::morethuente","",107,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::neldermead","",108,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::newton::newton_cg","",109,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::newton::newton_method","",110,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::particleswarm","",112,[[["__d"]],["result"]]],[11,"deserialize","","",111,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::quasinewton::bfgs","",113,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::quasinewton::dfp","",114,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::quasinewton::lbfgs","",115,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::quasinewton::sr1","",116,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::quasinewton::sr1_trustregion","",117,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::simulatedannealing","",118,[[["__d"]],["result"]]],[11,"deserialize","","",119,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::trustregion::cauchypoint","",120,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::trustregion::dogleg","",121,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::trustregion::steihaug","",122,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::trustregion::trustregion_method","",123,[[["__d"]],["result"]]],[11,"serialize","argmin::core","",2,[[["record"],["self"],["serializer"]],["result"]]],[11,"serialize","","",0,[[["record"],["self"],["serializer"]],["result"]]],[11,"new","","Create a new error object from any error type.",124,[[["e"]],["error"]]],[11,"msg","","Create a new error object from a printable error message.",124,[[["m"]],["error"]]],[11,"context","","Wrap the error value with additional context.",124,[[["c"]],["error"]]],[11,"chain","","An iterator of the chain of source errors contained by…",124,[[["self"]],["chain"]]],[11,"root_cause","","The lowest level cause of this error — this error's…",124,[[["self"]],["error"]]],[11,"is","","Returns true if `E` is the type held by this error object.",124,[[["self"]],["bool"]]],[11,"downcast","","Attempt to downcast the error object to a concrete type.",124,[[],[["result",["error"]],["error"]]]],[11,"downcast_ref","","Downcast this error object by reference.",124,[[["self"]],[["option"],["e"]]]],[11,"downcast_mut","","Downcast this error object by mutable reference.",124,[[["self"]],[["option"],["e"]]]],[11,"observe_init","","Called once at the beginning of the execution of the solver.",42,[[["str"],["argminkv"],["self"]],[["result",["error"]],["error"]]]],[11,"observe_iter","","Called at every iteration of the solver",42,[[["argminkv"],["self"],["iterstate"]],[["result",["error"]],["error"]]]]],"p":[[3,"IterState"],[3,"ArgminKV"],[3,"ArgminSlogKV"],[3,"OpWrapper"],[3,"ArgminResult"],[4,"ArgminError"],[13,"InvalidParameter"],[13,"NotImplemented"],[13,"NotInitialized"],[13,"ConditionViolated"],[13,"CheckpointNotFound"],[13,"ImpossibleError"],[4,"WriteToFileSerializer"],[4,"ObserverMode"],[4,"CheckpointMode"],[4,"TerminationReason"],[3,"Executor"],[3,"NoOperator"],[3,"MinimalNoOperator"],[3,"WriteToFile"],[3,"ArgminSlogLogger"],[3,"Visualizer3d"],[3,"Surface"],[3,"Observer"],[3,"ArgminCheckpoint"],[8,"ArgminDot"],[8,"ArgminWeightedDot"],[8,"ArgminZero"],[8,"ArgminConj"],[8,"ArgminZeroLike"],[8,"ArgminEye"],[8,"ArgminAdd"],[8,"ArgminSub"],[8,"ArgminMul"],[8,"ArgminDiv"],[8,"ArgminScaledAdd"],[8,"ArgminScaledSub"],[8,"ArgminNorm"],[8,"ArgminTranspose"],[8,"ArgminInv"],[8,"ArgminRandom"],[8,"ArgminMinMax"],[8,"Observe"],[8,"ArgminOp"],[8,"Solver"],[8,"ArgminLineSearch"],[8,"ArgminTrustRegion"],[8,"ArgminNLCGBetaUpdate"],[3,"ArgminIterData"],[8,"Bounded"],[8,"ToPrimitive"],[8,"FromPrimitive"],[8,"NumCast"],[8,"AsPrimitive"],[8,"FloatCore"],[8,"Float"],[8,"FloatConst"],[8,"Zero"],[8,"One"],[8,"PrimInt"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"CheckedRem"],[8,"CheckedNeg"],[8,"CheckedShl"],[8,"CheckedShr"],[8,"Inv"],[8,"MulAdd"],[8,"MulAddAssign"],[8,"Saturating"],[8,"SaturatingAdd"],[8,"SaturatingSub"],[8,"SaturatingMul"],[8,"WrappingAdd"],[8,"WrappingSub"],[8,"WrappingMul"],[8,"WrappingNeg"],[8,"WrappingShl"],[8,"WrappingShr"],[8,"Pow"],[8,"Real"],[8,"Signed"],[8,"Num"],[4,"FloatErrorKind"],[3,"ParseFloatError"],[4,"BrentError"],[3,"Brent"],[3,"ConjugateGradient"],[3,"NonlinearConjugateGradient"],[3,"FletcherReeves"],[3,"PolakRibiere"],[3,"PolakRibierePlus"],[3,"HestenesStiefel"],[3,"GaussNewtonLS"],[3,"GaussNewton"],[3,"GoldenSectionSearch"],[3,"SteepestDescent"],[3,"Landweber"],[3,"BacktrackingLineSearch"],[8,"LineSearchCondition"],[3,"ArmijoCondition"],[3,"WolfeCondition"],[3,"StrongWolfeCondition"],[3,"GoldsteinCondition"],[3,"HagerZhangLineSearch"],[3,"MoreThuenteLineSearch"],[3,"NelderMead"],[3,"NewtonCG"],[3,"Newton"],[3,"Particle"],[3,"ParticleSwarm"],[3,"BFGS"],[3,"DFP"],[3,"LBFGS"],[3,"SR1"],[3,"SR1TrustRegion"],[4,"SATempFunc"],[3,"SimulatedAnnealing"],[3,"CauchyPoint"],[3,"Dogleg"],[3,"Steihaug"],[3,"TrustRegion"],[3,"Error"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);