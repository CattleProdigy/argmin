var searchIndex={};
searchIndex["argmin"] = {"doc":"A pure Rust optimization framework","i":[[0,"core","argmin","Core functionality Argmin Optimizaton toolbox core",null,null],[3,"Error","argmin::core","The `Error` type, a wrapper around a dynamic error type.",null,null],[3,"IterState","","Maintains the state from iteration to iteration of a solver",null,null],[12,"param","","Current parameter vector",0,null],[12,"prev_param","","Previous parameter vector",0,null],[12,"best_param","","Current best parameter vector",0,null],[12,"prev_best_param","","Previous best parameter vector",0,null],[12,"cost","","Current cost function value",0,null],[12,"prev_cost","","Previous cost function value",0,null],[12,"best_cost","","Current best cost function value",0,null],[12,"prev_best_cost","","Previous best cost function value",0,null],[12,"target_cost","","Target cost function value",0,null],[12,"grad","","Current gradient",0,null],[12,"prev_grad","","Previous gradient",0,null],[12,"hessian","","Current Hessian",0,null],[12,"prev_hessian","","Previous Hessian",0,null],[12,"jacobian","","Current Jacobian",0,null],[12,"prev_jacobian","","Previous Jacobian",0,null],[12,"population","","All members for population-based algorithms as (param,…",0,null],[12,"iter","","Current iteration",0,null],[12,"last_best_iter","","Iteration number of last best cost",0,null],[12,"max_iters","","Maximum number of iterations",0,null],[12,"cost_func_count","","Number of cost function evaluations so far",0,null],[12,"grad_func_count","","Number of gradient evaluations so far",0,null],[12,"hessian_func_count","","Number of Hessian evaluations so far",0,null],[12,"jacobian_func_count","","Number of Jacobian evaluations so far",0,null],[12,"modify_func_count","","Number of modify evaluations so far",0,null],[12,"time","","Time required so far",0,null],[12,"termination_reason","","Reason of termination",0,null],[3,"ArgminKV","","A simple key-value storage",null,null],[12,"kv","","The actual key value storage",1,null],[3,"NoOperator","","Fake Operators for testing No-op operator with free choice…",null,null],[3,"MinimalNoOperator","","Minimal No-op operator which does nothing, really.",null,null],[3,"WriteToFile","","Write parameter vectors to file",null,null],[3,"ArgminSlogLogger","","A logger based on `slog`",null,null],[3,"ArgminSlogKV","","This type is necessary in order to be able to implement…",null,null],[12,"kv","","Key value store",2,null],[3,"Visualizer3d","","Visualize iterations of a solver for cost functions of…",null,null],[3,"Surface","","Helper class for visualized surface",null,null],[3,"Observer","","Container for observers which acts just like a single…",null,null],[3,"OpWrapper","","This wraps an operator and keeps track of how often the…",null,null],[12,"op","","Operator",3,null],[12,"cost_func_count","","Number of cost function evaluations",3,null],[12,"grad_func_count","","Number of gradient function evaluations",3,null],[12,"hessian_func_count","","Number of Hessian function evaluations",3,null],[12,"jacobian_func_count","","Number of Jacobian function evaluations",3,null],[12,"modify_func_count","","Number of `modify` function evaluations",3,null],[3,"ArgminResult","","Final struct returned by the `run` method of `Executor`.",null,null],[12,"operator","","operator",4,null],[12,"state","","iteration state",4,null],[3,"ArgminCheckpoint","","Checkpoint",null,null],[3,"ArgminIterData","","The datastructure which is returned by the `next_iter`…",null,null],[4,"ArgminError","","Argmin error type",null,null],[13,"InvalidParameter","","Indicates and invalid parameter",5,null],[12,"text","argmin::core::ArgminError","Text",5,null],[13,"NotImplemented","argmin::core","Indicates that a function is not implemented",5,null],[12,"text","argmin::core::ArgminError","Text",5,null],[13,"NotInitialized","argmin::core","Indicates that a function is not initialized",5,null],[12,"text","argmin::core::ArgminError","Text",5,null],[13,"ConditionViolated","argmin::core","Indicates that a condition is violated",5,null],[12,"text","argmin::core::ArgminError","Text",5,null],[13,"CheckpointNotFound","argmin::core","Checkpoint was not found",5,null],[12,"text","argmin::core::ArgminError","Text",5,null],[13,"ImpossibleError","argmin::core","Indicates an impossible error",5,null],[12,"text","argmin::core::ArgminError","Text",5,null],[4,"WriteToFileSerializer","argmin::core","Different kinds of serializers",null,null],[13,"Bincode","","Bincode",6,null],[13,"JSON","","JSON",6,null],[4,"ObserverMode","","This is used to indicate how often the observer will…",null,null],[13,"Never","","Never call the observer",7,null],[13,"Always","","Call observer in every iteration",7,null],[13,"Every","","Call observer every N iterations",7,null],[13,"NewBest","","Call observer when new best is found",7,null],[4,"CheckpointMode","","Defines at which intervals a checkpoint is saved.",null,null],[13,"Never","","Never create checkpoint",8,null],[13,"Every","","Create checkpoint every N iterations",8,null],[13,"Always","","Create checkpoint in every iteration",8,null],[4,"TerminationReason","","Indicates why the optimization algorithm stopped",null,null],[13,"NotTerminated","","In case it has not terminated yet",9,null],[13,"MaxItersReached","","Maximum number of iterations reached",9,null],[13,"TargetCostReached","","Target cost function value reached",9,null],[13,"TargetPrecisionReached","","Target precision reached",9,null],[13,"NoChangeInCost","","Cost function value did not change",9,null],[13,"AcceptedStallIterExceeded","","Acceped stall iter exceeded",9,null],[13,"BestStallIterExceeded","","Best stall iter exceeded",9,null],[13,"LineSearchConditionMet","","Condition for Line search met",9,null],[13,"TargetToleranceReached","","Target tolerance reached",9,null],[13,"Aborted","","Aborted",9,null],[5,"load_checkpoint","","Load a checkpoint from disk",null,[[["path"],["asref",["path"]]],[["error"],["result",["error"]],["deserializeowned"]]]],[0,"macros","","Macros # Macros",null,null],[0,"executor","","Executor",null,null],[3,"Executor","argmin::core::executor","Executes a solver",null,null],[12,"op","","operator",10,null],[11,"new","","Create a new executor with a `solver` and an initial…",10,[[["o"],["s"]],["self"]]],[11,"from_checkpoint","","Create a new executor from a checkpoint",10,[[["path"],["o"],["asref",["path"]]],[["error"],["result",["error"]]]]],[11,"run","","Run the executor",10,[[],[["error"],["result",["argminresult","error"]],["argminresult"]]]],[11,"add_observer","","Attaches a observer which implements `ArgminLog` to the…",10,[[["observe"],["observermode"]],["self"]]],[11,"max_iters","","Set maximum number of iterations",10,[[["u64"]],["self"]]],[11,"target_cost","","Set target cost value",10,[[],["self"]]],[11,"cost","","Set cost value",10,[[],["self"]]],[11,"grad","","Set Gradient",10,[[],["self"]]],[11,"hessian","","Set Hessian",10,[[],["self"]]],[11,"jacobian","","Set Jacobian",10,[[],["self"]]],[11,"checkpoint_dir","","Set checkpoint directory",10,[[["str"]],["self"]]],[11,"checkpoint_name","","Set checkpoint name",10,[[["str"]],["self"]]],[11,"checkpoint_mode","","Set the checkpoint mode",10,[[["checkpointmode"]],["self"]]],[11,"ctrlc","","Turn Ctrl-C handling on or off (default: on)",10,[[["bool"]],["self"]]],[11,"new","argmin::core","Create new IterState from `param`",0,[[],["self"]]],[11,"param","","Set parameter vector. This shifts the stored parameter…",0,[[["self"]],["self"]]],[11,"best_param","","Set best paramater vector. This shifts the stored best…",0,[[["self"]],["self"]]],[11,"cost","","Set the current cost function value. This shifts the…",0,[[["self"]],["self"]]],[11,"best_cost","","Set the current best cost function value. This shifts the…",0,[[["self"]],["self"]]],[11,"grad","","Set gradient. This shifts the stored gradient to the…",0,[[["self"]],["self"]]],[11,"hessian","","Set Hessian. This shifts the stored Hessian to the…",0,[[["self"]],["self"]]],[11,"jacobian","","Set Jacobian. This shifts the stored Jacobian to the…",0,[[["self"]],["self"]]],[11,"population","","Set population",0,[[["vec"],["self"]],["self"]]],[11,"target_cost","","Set",0,[[["self"]],["self"]]],[11,"max_iters","","Set",0,[[["self"],["u64"]],["self"]]],[11,"last_best_iter","","Set",0,[[["self"],["u64"]],["self"]]],[11,"termination_reason","","Set",0,[[["self"],["terminationreason"]],["self"]]],[11,"time","","Set",0,[[["self"],["duration"]],["self"]]],[11,"get_param","","Get",0,[[["self"]]]],[11,"get_prev_param","","Get",0,[[["self"]]]],[11,"get_best_param","","Get",0,[[["self"]]]],[11,"get_prev_best_param","","Get",0,[[["self"]]]],[11,"get_cost","","Get",0,[[["self"]]]],[11,"get_prev_cost","","Get",0,[[["self"]]]],[11,"get_best_cost","","Get",0,[[["self"]]]],[11,"get_prev_best_cost","","Get",0,[[["self"]]]],[11,"get_target_cost","","Get",0,[[["self"]]]],[11,"get_cost_func_count","","Get",0,[[["self"]],["u64"]]],[11,"get_grad_func_count","","Get",0,[[["self"]],["u64"]]],[11,"get_hessian_func_count","","Get",0,[[["self"]],["u64"]]],[11,"get_jacobian_func_count","","Get",0,[[["self"]],["u64"]]],[11,"get_modify_func_count","","Get",0,[[["self"]],["u64"]]],[11,"get_last_best_iter","","Get",0,[[["self"]],["u64"]]],[11,"get_termination_reason","","Get",0,[[["self"]],["terminationreason"]]],[11,"get_time","","Get",0,[[["self"]],["duration"]]],[11,"get_grad","","Get",0,[[["self"]],["option"]]],[11,"get_prev_grad","","Get",0,[[["self"]],["option"]]],[11,"get_hessian","","Get",0,[[["self"]],["option"]]],[11,"get_prev_hessian","","Get",0,[[["self"]],["option"]]],[11,"get_jacobian","","Get",0,[[["self"]],["option"]]],[11,"get_prev_jacobian","","Get",0,[[["self"]],["option"]]],[11,"get_iter","","Get",0,[[["self"]],["u64"]]],[11,"get_max_iters","","Get",0,[[["self"]],["u64"]]],[11,"get_population","","Returns population",0,[[["self"]],[["option",["vec"]],["vec"]]]],[11,"increment_iter","","Increment the number of iterations by one",0,[[["self"]]]],[11,"increment_func_counts","","Increment all function evaluation counts by the evaluation…",0,[[["self"],["opwrapper"]]]],[11,"set_func_counts","","Set all function evaluation counts to the evaluation…",0,[[["self"],["opwrapper"]]]],[11,"increment_cost_func_count","","Increment cost function evaluation count by `num`",0,[[["self"],["u64"]]]],[11,"increment_grad_func_count","","Increment gradient function evaluation count by `num`",0,[[["self"],["u64"]]]],[11,"increment_hessian_func_count","","Increment Hessian function evaluation count by `num`",0,[[["self"],["u64"]]]],[11,"increment_jacobian_func_count","","Increment Jacobian function evaluation count by `num`",0,[[["self"],["u64"]]]],[11,"increment_modify_func_count","","Increment modify function evaluation count by `num`",0,[[["self"],["u64"]]]],[11,"new_best","","Indicate that a new best parameter vector was found",0,[[["self"]]]],[11,"is_best","","Returns whether the current parameter vector is also the…",0,[[["self"]],["bool"]]],[11,"terminated","","Return whether the algorithm has terminated or not",0,[[["self"]],["bool"]]],[11,"new","","Constructor",1,[[],["self"]]],[11,"push","","Push a key-value pair to the `kv` vector.",1,[[["display"],["self"],["str"]],["self"]]],[11,"merge","","Merge another `kv` into `self.kv`",1,[[["argminkv"]],["self"]]],[11,"new","","Constructor",11,[[],["self"]]],[11,"new","","Constructor",12,[[],["self"]]],[11,"new","","Create a new `WriteToFile` struct",13,[[["str"]],["self"]]],[11,"serializer","","Set serializer",13,[[["writetofileserializer"]],["self"]]],[11,"term","","Log to the terminal in a blocking way",14,[[],["self"]]],[11,"term_noblock","","Log to the terminal in a non-blocking way (in case of…",14,[[],["self"]]],[11,"file","","Log JSON to a file in a blocking way",14,[[["str"],["bool"]],[["error"],["result",["error"]]]]],[11,"file_noblock","","Log JSON to a file in a non-blocking way (in case of…",14,[[["str"],["bool"]],[["error"],["result",["error"]]]]],[11,"new","","Create a new visualizer",15,[[],["self"]]],[11,"delay","","Set delay",15,[[["duration"]],["self"]]],[11,"surface","","Set surface",15,[[["surface"]],["self"]]],[11,"new","","Create a new surface",16,[[["o"],["f64"]],["self"]]],[11,"new","","Constructor",17,[[],["self"]]],[11,"push","","Push another `Observe` to the `observer` field",17,[[["observe"],["self"],["observermode"]],["self"]]],[11,"new","","Constructor",3,[[["o"]],["self"]]],[11,"new_from_wrapper","","Construct struct from other `OpWrapper`. Takes the…",3,[[["opwrapper"]],["self"]]],[11,"apply","","Calls the `apply` method of `op` and increments…",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"gradient","","Calls the `gradient` method of `op` and increments…",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"hessian","","Calls the `hessian` method of `op` and increments…",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"jacobian","","Calls the `jacobian` method of `op` and increments…",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"modify","","Calls the `modify` method of `op` and increments…",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"take_op","","Moves the operator out of the struct and replaces it with…",3,[[["self"]],["option"]]],[11,"consume_op","","Consumes an operator by increasing the function call…",3,[[["self"],["opwrapper"]]]],[11,"consume_func_counts","","Adds function evaluation counts of another operator.",3,[[["self"],["argminop"],["opwrapper"]]]],[11,"reset","","Reset the cost function counts to zero.",3,[[],["self"]]],[11,"get_op","","Returns the operator `op` by taking ownership of `self`.",3,[[],["o"]]],[11,"new","","Constructor",4,[[["o"],["iterstate"]],["self"]]],[11,"operator","","Return handle to operator",4,[[["self"]],["o"]]],[11,"state","","Return handle to state",4,[[["self"]],["iterstate"]]],[11,"new","","Define a new checkpoint",18,[[["str"],["checkpointmode"]],[["error"],["result",["error"]]]]],[11,"set_dir","","Set directory of checkpoint",18,[[["str"],["self"]]]],[11,"dir","","Get directory of checkpoint",18,[[["self"]],["string"]]],[11,"set_name","","Set name of checkpoint",18,[[["str"],["self"]]]],[11,"name","","Get name of checkpoint",18,[[["self"]],["string"]]],[11,"set_mode","","Set mode of checkpoint",18,[[["self"],["checkpointmode"]]]],[11,"store","","Write checkpoint to disk",18,[[["t"],["self"],["string"]],[["result",["error"]],["error"]]]],[11,"store_cond","","Write checkpoint based on the desired `CheckpointMode`",18,[[["t"],["self"],["u64"]],[["result",["error"]],["error"]]]],[11,"terminated","","Returns `true` if a solver terminated and `false` otherwise",9,[[],["bool"]]],[11,"text","","Returns a texual representation of what happened",9,[[["self"]],["str"]]],[0,"file","","Output parameter vectors to file",null,null],[3,"WriteToFile","argmin::core::file","Write parameter vectors to file",null,null],[4,"WriteToFileSerializer","","Different kinds of serializers",null,null],[13,"Bincode","","Bincode",6,null],[13,"JSON","","JSON",6,null],[0,"slog_logger","argmin::core","Loggers based on the `slog` crate",null,null],[3,"ArgminSlogLogger","argmin::core::slog_logger","A logger based on `slog`",null,null],[3,"ArgminSlogKV","","This type is necessary in order to be able to implement…",null,null],[12,"kv","","Key value store",2,null],[0,"visualizer","argmin::core","Observer which visualizes the progress of the solver",null,null],[3,"Visualizer3d","argmin::core::visualizer","Visualize iterations of a solver for cost functions of…",null,null],[3,"Surface","","Helper class for visualized surface",null,null],[8,"ArgminDot","argmin::core","Dot/scalar product of `T` and `self`",null,null],[10,"dot","","Dot/scalar product of `T` and `self`",19,[[["t"],["self"]],["u"]]],[8,"ArgminWeightedDot","","Dot/scalar product of `T` and `self` weighted by W (p^TWv)",null,null],[10,"weighted_dot","","Dot/scalar product of `T` and `self`",20,[[["v"],["self"],["t"]],["u"]]],[8,"ArgminZero","","Return param vector of all zeros (for now, this is a hack.…",null,null],[10,"zero","","Return zero(s)",21,[[],["self"]]],[8,"ArgminConj","","Return the conjugate",null,null],[10,"conj","","Return conjugate",22,[[["self"]],["self"]]],[8,"ArgminZeroLike","","Zero for dynamically sized objects",null,null],[10,"zero_like","","Return zero(s)",23,[[["self"]],["self"]]],[8,"ArgminEye","","Identity matrix",null,null],[10,"eye","","Identity matrix of size `n`",24,[[["usize"]],["self"]]],[10,"eye_like","","Identity matrix of same size as `self`",24,[[["self"]],["self"]]],[8,"ArgminAdd","","Add a `T` to `self`",null,null],[10,"add","","Add a `T` to `self`",25,[[["t"],["self"]],["u"]]],[8,"ArgminSub","","Subtract a `T` from `self`",null,null],[10,"sub","","Subtract a `T` from `self`",26,[[["t"],["self"]],["u"]]],[8,"ArgminMul","","(Pointwise) Multiply a `T` with `self`",null,null],[10,"mul","","(Pointwise) Multiply a `T` with `self`",27,[[["t"],["self"]],["u"]]],[8,"ArgminDiv","","(Pointwise) Divide a `T` by `self`",null,null],[10,"div","","(Pointwise) Divide a `T` by `self`",28,[[["t"],["self"]],["u"]]],[8,"ArgminScaledAdd","","Add a `T` scaled by an `U` to `self`",null,null],[10,"scaled_add","","Add a `T` scaled by an `U` to `self`",29,[[["t"],["self"],["u"]],["v"]]],[8,"ArgminScaledSub","","Subtract a `T` scaled by an `U` from `self`",null,null],[10,"scaled_sub","","Subtract a `T` scaled by an `U` from `self`",30,[[["t"],["self"],["u"]],["v"]]],[8,"ArgminNorm","","Compute the l2-norm (`U`) of `self`",null,null],[10,"norm","","Compute the l2-norm (`U`) of `self`",31,[[["self"]],["u"]]],[8,"ArgminTranspose","","Transposing a type",null,null],[10,"t","","Transpose",32,[[],["self"]]],[8,"ArgminInv","","Compute the inverse (`T`) of `self`",null,null],[10,"inv","","Compute the inverse",33,[[["self"]],[["error"],["result",["error"]]]]],[8,"ArgminRandom","","Create a random number",null,null],[10,"rand_from_range","","Get a random element between min and max,",34,[[["self"]],["self"]]],[8,"ArgminMinMax","","Minimum and Maximum of type `T`",null,null],[10,"min","","Select piecewise minimum",35,[[["self"]],["self"]]],[10,"max","","Select piecewise maximum",35,[[["self"]],["self"]]],[8,"Observe","","Defines the interface every Observer needs to expose",null,null],[11,"observe_init","","Called once at the beginning of the execution of the solver.",36,[[["str"],["argminkv"],["self"]],[["result",["error"]],["error"]]]],[11,"observe_iter","","Called at every iteration of the solver",36,[[["self"],["iterstate"],["argminkv"]],[["result",["error"]],["error"]]]],[8,"ArgminFloat","","Trait alias to simplify common trait bounds",null,null],[8,"ArgminOp","","This trait needs to be implemented for every operator/cost…",null,null],[16,"Param","","Type of the parameter vector",37,null],[16,"Output","","Output of the operator",37,null],[16,"Hessian","","Type of Hessian",37,null],[16,"Jacobian","","Type of Jacobian",37,null],[16,"Float","","Precision of floats",37,null],[11,"apply","","Applies the operator/cost function to parameters",37,[[["self"]],[["error"],["result",["error"]]]]],[11,"gradient","","Computes the gradient at the given parameters",37,[[["self"]],[["error"],["result",["error"]]]]],[11,"hessian","","Computes the Hessian at the given parameters",37,[[["self"]],[["error"],["result",["error"]]]]],[11,"jacobian","","Computes the Hessian at the given parameters",37,[[["self"]],[["error"],["result",["error"]]]]],[11,"modify","","Modifies a parameter vector. Comes with a variable that…",37,[[["self"]],[["error"],["result",["error"]]]]],[8,"Solver","","Solver",null,null],[18,"NAME","","Name of the solver",38,null],[10,"next_iter","","Computes one iteration of the algorithm.",38,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"init","","Initializes the algorithm",38,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"terminate_internal","","Checks whether basic termination reasons apply.",38,[[["self"],["iterstate"]],["terminationreason"]]],[11,"terminate","","Checks whether the algorithm must be terminated",38,[[["self"],["iterstate"]],["terminationreason"]]],[8,"ArgminLineSearch","","Defines a common interface for line search methods.",null,null],[10,"set_search_direction","","Set the search direction",39,[[["self"],["p"]]]],[10,"set_init_alpha","","Set the initial step length",39,[[["self"],["f"]],[["result",["error"]],["error"]]]],[8,"ArgminTrustRegion","","Defines a common interface to methods which calculate…",null,null],[10,"set_radius","","Set the initial step length",40,[[["self"],["f"]]]],[8,"ArgminNLCGBetaUpdate","","Common interface for beta update methods (Nonlinear-CG)",null,null],[10,"update","","Update beta Parameter 1: \\nabla f_k Parameter 2: \\nabla…",41,[[["t"],["self"]],["f"]]],[11,"new","","Constructor",42,[[],["self"]]],[11,"param","","Set parameter vector",42,[[],["self"]]],[11,"cost","","Set cost function value",42,[[],["self"]]],[11,"grad","","Set gradient",42,[[],["self"]]],[11,"hessian","","Set Hessian",42,[[],["self"]]],[11,"jacobian","","Set Jacobian",42,[[],["self"]]],[11,"population","","Set Population",42,[[["vec"]],["self"]]],[11,"kv","","Adds an `ArgminKV`",42,[[["argminkv"]],["self"]]],[11,"termination_reason","","Set termination reason",42,[[["terminationreason"]],["self"]]],[11,"get_param","","Get parameter vector",42,[[["self"]],["option"]]],[11,"get_cost","","Get cost function value",42,[[["self"]],["option"]]],[11,"get_grad","","Get gradient",42,[[["self"]],["option"]]],[11,"get_hessian","","Get Hessian",42,[[["self"]],["option"]]],[11,"get_jacobian","","Get Jacobian",42,[[["self"]],["option"]]],[11,"get_population","","Get reference to population",42,[[["self"]],[["option",["vec"]],["vec"]]]],[11,"get_termination_reason","","Get termination reason",42,[[["self"]],[["terminationreason"],["option",["terminationreason"]]]]],[11,"get_kv","","Return KV",42,[[["self"]],["argminkv"]]],[0,"prelude","argmin","Definition of all relevant traits and types # Re-export of…",null,null],[0,"bounds","argmin::prelude","",null,null],[8,"Bounded","argmin::prelude::bounds","Numbers which have upper and lower bounds",null,null],[10,"min_value","","returns the smallest finite number this type can represent",43,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",43,[[],["self"]]],[0,"cast","argmin::prelude","",null,null],[8,"ToPrimitive","argmin::prelude::cast","A generic trait for converting a value to a number.",null,null],[11,"to_isize","","Converts the value of `self` to an `isize`. If the value…",44,[[["self"]],[["isize"],["option",["isize"]]]]],[11,"to_i8","","Converts the value of `self` to an `i8`. If the value…",44,[[["self"]],[["i8"],["option",["i8"]]]]],[11,"to_i16","","Converts the value of `self` to an `i16`. If the value…",44,[[["self"]],[["i16"],["option",["i16"]]]]],[11,"to_i32","","Converts the value of `self` to an `i32`. If the value…",44,[[["self"]],[["option",["i32"]],["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`. If the value…",44,[[["self"]],[["i64"],["option",["i64"]]]]],[11,"to_i128","","Converts the value of `self` to an `i128`. If the value…",44,[[["self"]],[["option",["i128"]],["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`. If the value…",44,[[["self"]],[["option",["usize"]],["usize"]]]],[11,"to_u8","","Converts the value of `self` to a `u8`. If the value…",44,[[["self"]],[["option",["u8"]],["u8"]]]],[11,"to_u16","","Converts the value of `self` to a `u16`. If the value…",44,[[["self"]],[["u16"],["option",["u16"]]]]],[11,"to_u32","","Converts the value of `self` to a `u32`. If the value…",44,[[["self"]],[["option",["u32"]],["u32"]]]],[10,"to_u64","","Converts the value of `self` to a `u64`. If the value…",44,[[["self"]],[["option",["u64"]],["u64"]]]],[11,"to_u128","","Converts the value of `self` to a `u128`. If the value…",44,[[["self"]],[["u128"],["option",["u128"]]]]],[11,"to_f32","","Converts the value of `self` to an `f32`. If the value…",44,[[["self"]],[["f32"],["option",["f32"]]]]],[11,"to_f64","","Converts the value of `self` to an `f64`. If the value…",44,[[["self"]],[["f64"],["option",["f64"]]]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Converts an `isize` to return an optional value of this…",45,[[["isize"]],["option"]]],[11,"from_i8","","Converts an `i8` to return an optional value of this type.…",45,[[["i8"]],["option"]]],[11,"from_i16","","Converts an `i16` to return an optional value of this…",45,[[["i16"]],["option"]]],[11,"from_i32","","Converts an `i32` to return an optional value of this…",45,[[["i32"]],["option"]]],[10,"from_i64","","Converts an `i64` to return an optional value of this…",45,[[["i64"]],["option"]]],[11,"from_i128","","Converts an `i128` to return an optional value of this…",45,[[["i128"]],["option"]]],[11,"from_usize","","Converts a `usize` to return an optional value of this…",45,[[["usize"]],["option"]]],[11,"from_u8","","Converts an `u8` to return an optional value of this type.…",45,[[["u8"]],["option"]]],[11,"from_u16","","Converts an `u16` to return an optional value of this…",45,[[["u16"]],["option"]]],[11,"from_u32","","Converts an `u32` to return an optional value of this…",45,[[["u32"]],["option"]]],[10,"from_u64","","Converts an `u64` to return an optional value of this…",45,[[["u64"]],["option"]]],[11,"from_u128","","Converts an `u128` to return an optional value of this…",45,[[["u128"]],["option"]]],[11,"from_f32","","Converts a `f32` to return an optional value of this type.…",45,[[["f32"]],["option"]]],[11,"from_f64","","Converts a `f64` to return an optional value of this type.…",45,[[["f64"]],["option"]]],[5,"cast","","Cast from one machine scalar to another.",null,[[["t"]],["option"]]],[8,"NumCast","","An interface for casting between machine scalars.",null,null],[10,"from","","Creates a number from another value that can be converted…",46,[[["t"]],["option"]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars…",null,null],[10,"as_","","Convert a value to another, using the `as` operator.",47,[[],["t"]]],[0,"float","argmin::prelude","",null,null],[8,"FloatCore","argmin::prelude::float","Generic trait for floating point numbers that works with…",null,null],[10,"infinity","","Returns positive infinity.",48,[[],["self"]]],[10,"neg_infinity","","Returns negative infinity.",48,[[],["self"]]],[10,"nan","","Returns NaN.",48,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",48,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can…",48,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",48,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",48,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",48,[[],["self"]]],[11,"is_nan","","Returns `true` if the number is NaN.",48,[[],["bool"]]],[11,"is_infinite","","Returns `true` if the number is infinite.",48,[[],["bool"]]],[11,"is_finite","","Returns `true` if the number is neither infinite or NaN.",48,[[],["bool"]]],[11,"is_normal","","Returns `true` if the number is neither zero, infinite,…",48,[[],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only…",48,[[],["fpcategory"]]],[11,"floor","","Returns the largest integer less than or equal to a number.",48,[[],["self"]]],[11,"ceil","","Returns the smallest integer greater than or equal to a…",48,[[],["self"]]],[11,"round","","Returns the nearest integer to a number. Round half-way…",48,[[],["self"]]],[11,"trunc","","Return the integer part of a number.",48,[[],["self"]]],[11,"fract","","Returns the fractional part of a number.",48,[[],["self"]]],[11,"abs","","Computes the absolute value of `self`. Returns…",48,[[],["self"]]],[11,"signum","","Returns a number that represents the sign of `self`.",48,[[],["self"]]],[11,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and…",48,[[],["bool"]]],[11,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and…",48,[[],["bool"]]],[11,"min","","Returns the minimum of the two numbers.",48,[[],["self"]]],[11,"max","","Returns the maximum of the two numbers.",48,[[],["self"]]],[11,"recip","","Returns the reciprocal (multiplicative inverse) of the…",48,[[],["self"]]],[11,"powi","","Raise a number to an integer power.",48,[[["i32"]],["self"]]],[10,"to_degrees","","Converts to degrees, assuming the number is in radians.",48,[[],["self"]]],[10,"to_radians","","Converts to radians, assuming the number is in degrees.",48,[[],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",48,[[]]],[8,"Float","","Generic trait for floating point numbers",null,null],[10,"nan","","Returns the `NaN` value.",49,[[],["self"]]],[10,"infinity","","Returns the infinite value.",49,[[],["self"]]],[10,"neg_infinity","","Returns the negative infinite value.",49,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",49,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can…",49,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",49,[[],["self"]]],[11,"epsilon","","Returns epsilon, a small positive value.",49,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",49,[[],["self"]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",49,[[],["bool"]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or…",49,[[],["bool"]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",49,[[],["bool"]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite,…",49,[[],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only…",49,[[],["fpcategory"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",49,[[],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a…",49,[[],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way…",49,[[],["self"]]],[10,"trunc","","Return the integer part of a number.",49,[[],["self"]]],[10,"fract","","Returns the fractional part of a number.",49,[[],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns…",49,[[],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",49,[[],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`,…",49,[[],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`,…",49,[[],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only…",49,[[],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",49,[[],["self"]]],[10,"powi","","Raise a number to an integer power.",49,[[["i32"]],["self"]]],[10,"powf","","Raise a number to a floating point power.",49,[[],["self"]]],[10,"sqrt","","Take the square root of a number.",49,[[],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",49,[[],["self"]]],[10,"exp2","","Returns `2^(self)`.",49,[[],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",49,[[],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an…",49,[[],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",49,[[],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",49,[[],["self"]]],[11,"to_degrees","","Converts radians to degrees.",49,[[],["self"]]],[11,"to_radians","","Converts degrees to radians.",49,[[],["self"]]],[10,"max","","Returns the maximum of the two numbers.",49,[[],["self"]]],[10,"min","","Returns the minimum of the two numbers.",49,[[],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",49,[[],["self"]]],[10,"cbrt","","Take the cubic root of a number.",49,[[],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle…",49,[[],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",49,[[],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",49,[[],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",49,[[],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in…",49,[[],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in…",49,[[],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in…",49,[[],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and…",49,[[],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number,…",49,[[]]],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if…",49,[[],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than…",49,[[],["self"]]],[10,"sinh","","Hyperbolic sine function.",49,[[],["self"]]],[10,"cosh","","Hyperbolic cosine function.",49,[[],["self"]]],[10,"tanh","","Hyperbolic tangent function.",49,[[],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",49,[[],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",49,[[],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",49,[[],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",49,[[]]],[8,"FloatConst","","",null,null],[10,"E","","Return Euler’s number.",50,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",50,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",50,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",50,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",50,[[],["self"]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",50,[[],["self"]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",50,[[],["self"]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",50,[[],["self"]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",50,[[],["self"]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",50,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",50,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",50,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",50,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",50,[[],["self"]]],[10,"PI","","Return Archimedes’ constant `π`.",50,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",50,[[],["self"]]],[11,"TAU","","Return the full circle constant `τ`.",50,[[],["self"]]],[0,"identities","argmin::prelude","",null,null],[8,"Zero","argmin::prelude::identities","Defines an additive identity element for `Self`.",null,null],[10,"zero","","Returns the additive identity element of `Self`, `0`. #…",51,[[],["self"]]],[11,"set_zero","","Sets `self` to the additive identity element of `Self`, `0`.",51,[[["self"]]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",51,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",null,null],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",52,[[],["self"]]],[11,"set_one","","Sets `self` to the multiplicative identity element of…",52,[[["self"]]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative…",52,[[["self"]],["bool"]]],[5,"zero","","Returns the additive identity, `0`.",null,[[],["t"]]],[5,"one","","Returns the multiplicative identity, `1`.",null,[[],["t"]]],[0,"int","argmin::prelude","",null,null],[8,"PrimInt","argmin::prelude::int","Generic trait for primitive integers.",null,null],[10,"count_ones","","Returns the number of ones in the binary representation of…",53,[[],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation…",53,[[],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary…",53,[[],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary…",53,[[],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount,…",53,[[["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount,…",53,[[["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount,…",53,[[["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount,…",53,[[["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount,…",53,[[["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount,…",53,[[["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",53,[[],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's…",53,[[],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's…",53,[[],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",53,[[],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's…",53,[[],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by…",53,[[["u32"]],["self"]]],[0,"ops","argmin::prelude","",null,null],[0,"checked","argmin::prelude::ops","",null,null],[8,"CheckedAdd","argmin::prelude::ops::checked","Performs addition that returns `None` instead of wrapping…",null,null],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow…",54,[[["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of…",null,null],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If…",55,[[["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of…",null,null],[10,"checked_mul","","Multiplies two numbers, checking for underflow or…",56,[[["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking…",null,null],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and…",57,[[["self"]],["option"]]],[8,"CheckedRem","","Performs an integral remainder that returns `None` instead…",null,null],[10,"checked_rem","","Finds the remainder of dividing two numbers, checking for…",58,[[["self"]],["option"]]],[8,"CheckedNeg","","Performs negation that returns `None` if the result can't…",null,null],[10,"checked_neg","","Negates a number, returning `None` for results that can't…",59,[[["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on shifts larger…",null,null],[10,"checked_shl","","Checked shift left. Computes `self << rhs`, returning…",60,[[["u32"],["self"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on shifts…",null,null],[10,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning…",61,[[["u32"],["self"]],["option"]]],[0,"inv","argmin::prelude::ops","",null,null],[8,"Inv","argmin::prelude::ops::inv","Unary operator for retrieving the multiplicative inverse,…",null,null],[16,"Output","","The result after applying the operator.",62,null],[10,"inv","","Returns the multiplicative inverse of `self`.",62,[[]]],[0,"mul_add","argmin::prelude::ops","",null,null],[8,"MulAdd","argmin::prelude::ops::mul_add","Fused multiply-add. Computes `(self * a) + b` with only…",null,null],[16,"Output","","The resulting type after applying the fused multiply-add.",63,null],[10,"mul_add","","Performs the fused multiply-add operation.",63,[[["a"],["b"]]]],[8,"MulAddAssign","","The fused multiply-add assignment operation.",null,null],[10,"mul_add_assign","","Performs the fused multiply-add operation.",64,[[["a"],["self"],["b"]]]],[0,"saturating","argmin::prelude::ops","",null,null],[8,"Saturating","argmin::prelude::ops::saturating","Saturating math operations",null,null],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at…",65,[[],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating…",65,[[],["self"]]],[0,"wrapping","argmin::prelude::ops","",null,null],[8,"WrappingAdd","argmin::prelude::ops::wrapping","Performs addition that wraps around on overflow.",null,null],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`,…",66,[[["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",null,null],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`,…",67,[[["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",null,null],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self *…",68,[[["self"]],["self"]]],[8,"WrappingShl","","Performs a left shift that does not panic.",null,null],[10,"wrapping_shl","","Panic-free bitwise shift-left; yields `self << mask(rhs)`,…",69,[[["u32"],["self"]],["self"]]],[8,"WrappingShr","","Performs a right shift that does not panic.",null,null],[10,"wrapping_shr","","Panic-free bitwise shift-right; yields `self >>…",70,[[["u32"],["self"]],["self"]]],[0,"pow","argmin::prelude","",null,null],[8,"Pow","argmin::prelude::pow","Binary operator for raising a value to a power.",null,null],[16,"Output","","The result after applying the operator.",71,null],[10,"pow","","Returns `self` to the power `rhs`.",71,[[["rhs"]]]],[5,"pow","","Raises a value to the power of exp, using exponentiation…",null,[[["t"],["usize"]],["t"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an…",null,[[["t"],["usize"]],["option"]]],[0,"real","argmin::prelude","",null,null],[8,"Real","argmin::prelude::real","A trait for real number types that do not necessarily have…",null,null],[10,"min_value","","Returns the smallest finite value that this type can…",72,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",72,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",72,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",72,[[],["self"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",72,[[],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a…",72,[[],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way…",72,[[],["self"]]],[10,"trunc","","Return the integer part of a number.",72,[[],["self"]]],[10,"fract","","Returns the fractional part of a number.",72,[[],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns…",72,[[],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",72,[[],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`,…",72,[[],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`,…",72,[[],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only…",72,[[],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",72,[[],["self"]]],[10,"powi","","Raise a number to an integer power.",72,[[["i32"]],["self"]]],[10,"powf","","Raise a number to a real number power.",72,[[],["self"]]],[10,"sqrt","","Take the square root of a number.",72,[[],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",72,[[],["self"]]],[10,"exp2","","Returns `2^(self)`.",72,[[],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",72,[[],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an…",72,[[],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",72,[[],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",72,[[],["self"]]],[10,"to_degrees","","Converts radians to degrees.",72,[[],["self"]]],[10,"to_radians","","Converts degrees to radians.",72,[[],["self"]]],[10,"max","","Returns the maximum of the two numbers.",72,[[],["self"]]],[10,"min","","Returns the minimum of the two numbers.",72,[[],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",72,[[],["self"]]],[10,"cbrt","","Take the cubic root of a number.",72,[[],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle…",72,[[],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",72,[[],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",72,[[],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",72,[[],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in…",72,[[],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in…",72,[[],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in…",72,[[],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and…",72,[[],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number,…",72,[[]]],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if…",72,[[],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than…",72,[[],["self"]]],[10,"sinh","","Hyperbolic sine function.",72,[[],["self"]]],[10,"cosh","","Hyperbolic cosine function.",72,[[],["self"]]],[10,"tanh","","Hyperbolic tangent function.",72,[[],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",72,[[],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",72,[[],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",72,[[],["self"]]],[0,"sign","argmin::prelude","",null,null],[8,"Signed","argmin::prelude::sign","Useful functions for signed numbers (i.e. numbers that can…",null,null],[10,"abs","","Computes the absolute value.",73,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",73,[[["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",73,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the…",73,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the…",73,[[["self"]],["bool"]]],[5,"abs","","Computes the absolute value.",null,[[["t"]],["t"]]],[5,"abs_sub","","The positive difference of two numbers.",null,[[["t"]],["t"]]],[5,"signum","","Returns the sign of the number.",null,[[["t"]],["t"]]],[8,"Unsigned","","A trait for values which cannot be negative",null,null],[8,"Num","argmin::prelude","The base trait for numeric types, covering `0` and `1`…",null,null],[16,"FromStrRadixErr","","",74,null],[10,"from_str_radix","","Convert from a string and radix <= 36.",74,[[["str"],["u32"]],["result"]]],[8,"NumOps","","The trait for types implementing basic numeric operations",null,null],[8,"NumRef","","The trait for `Num` types which also implement numeric…",null,null],[8,"RefNum","","The trait for references which implement numeric…",null,null],[8,"NumAssignOps","","The trait for types implementing numeric assignment…",null,null],[8,"NumAssign","","The trait for `Num` types which also implement assignment…",null,null],[8,"NumAssignRef","","The trait for `NumAssign` types which also implement…",null,null],[4,"FloatErrorKind","","",null,null],[13,"Empty","","",75,null],[13,"Invalid","","",75,null],[3,"ParseFloatError","","",null,null],[12,"kind","","",76,null],[5,"clamp","","A value bounded by a minimum and a maximum",null,[[["t"]],["t"]]],[5,"clamp_min","","A value bounded by a minimum value",null,[[["t"]],["t"]]],[5,"clamp_max","","A value bounded by a maximum value",null,[[["t"]],["t"]]],[0,"solver","argmin","Solvers",null,null],[0,"brent","argmin::solver","Brent's method",null,null],[3,"Brent","argmin::solver::brent","Brent's method",null,null],[4,"BrentError","","Error to be thrown if Brent is initialized with improper…",null,null],[13,"WrongSign","","f(min) and f(max) must have different signs",77,null],[11,"new","","Constructor The values `min` and `max` must bracketing the…",78,[[["f"]],["brent"]]],[0,"conjugategradient","argmin::solver","Conjugate Gradient methods",null,null],[0,"cg","argmin::solver::conjugategradient","Conjugate gradient method # References:",null,null],[3,"ConjugateGradient","argmin::solver::conjugategradient::cg","The conjugate gradient method is a solver for systems of…",null,null],[11,"new","","Constructor",79,[[["p"]],[["error"],["result",["error"]]]]],[11,"p","","Return the current search direction (This is needed by…",79,[[["self"]],["p"]]],[11,"p_prev","","Return the previous search direction (This is needed by…",79,[[["self"]],["p"]]],[11,"residual","","Return the current residual (This is needed by NewtonCG…",79,[[["self"]],["p"]]],[0,"nonlinear_cg","argmin::solver::conjugategradient","Nonlinear conjugate gradient method Important TODO: Find…",null,null],[3,"NonlinearConjugateGradient","argmin::solver::conjugategradient::nonlinear_cg","The nonlinear conjugate gradient is a generalization of…",null,null],[11,"new","","Constructor (Polak Ribiere Conjugate Gradient (PR-CG))",80,[[["b"],["l"]],[["error"],["result",["error"]]]]],[11,"restart_iters","","Specifiy the number of iterations after which a restart…",80,[[["u64"]],["self"]]],[11,"restart_orthogonality","","Set the value for the orthogonality measure. Setting this…",80,[[["f"]],["self"]]],[0,"beta","argmin::solver::conjugategradient","Beta update methods for nonlinear CG # Beta update methods",null,null],[3,"FletcherReeves","argmin::solver::conjugategradient::beta","Fletcher and Reeves (FR) method TODO: Reference",null,null],[3,"PolakRibiere","","Polak and Ribiere (PR) method TODO: Reference",null,null],[3,"PolakRibierePlus","","Polak and Ribiere Plus (PR+) method TODO: Reference",null,null],[3,"HestenesStiefel","","Hestenes and Stiefel (HS) method TODO: Reference",null,null],[11,"new","","Constructor",81,[[],["self"]]],[11,"new","","Constructor",82,[[],["self"]]],[11,"new","","Constructor",83,[[],["self"]]],[11,"new","","Constructor",84,[[],["self"]]],[0,"gaussnewton","argmin::solver","Newton Methods",null,null],[0,"gaussnewton_linesearch","argmin::solver::gaussnewton","Gauss-Newton method with linesearch # References:",null,null],[3,"GaussNewtonLS","argmin::solver::gaussnewton::gaussnewton_linesearch","Gauss-Newton method with linesearch",null,null],[11,"new","","Constructor",85,[[["l"]],["self"]]],[11,"with_tol","","Set tolerance for the stopping criterion based on cost…",85,[[["f"]],[["error"],["result",["error"]]]]],[0,"gaussnewton_method","argmin::solver::gaussnewton","Gauss-Newton method # References:",null,null],[3,"GaussNewton","argmin::solver::gaussnewton::gaussnewton_method","Gauss-Newton method",null,null],[11,"new","","Constructor",86,[[],["self"]]],[11,"with_gamma","","set gamma",86,[[["f"]],[["error"],["result",["error"]]]]],[11,"with_tol","","Set tolerance for the stopping criterion based on cost…",86,[[["f"]],[["error"],["result",["error"]]]]],[0,"gradientdescent","argmin::solver","Gradient descent methods",null,null],[0,"steepestdescent","argmin::solver::gradientdescent","Steepest Descent method",null,null],[3,"SteepestDescent","argmin::solver::gradientdescent::steepestdescent","Steepest descent iteratively takes steps in the direction…",null,null],[11,"new","","Constructor",87,[[["l"]],["self"]]],[0,"landweber","argmin::solver","Landweber iteration",null,null],[3,"Landweber","argmin::solver::landweber","The Landweber iteration is a solver for ill-posed linear…",null,null],[11,"new","","Constructor",88,[[["f"]],["self"]]],[0,"linesearch","argmin::solver","Line search methods",null,null],[0,"backtracking","argmin::solver::linesearch","Backtracking line search algorithm * Backtracking line…",null,null],[3,"BacktrackingLineSearch","argmin::solver::linesearch::backtracking","The Backtracking line search is a simple method to find a…",null,null],[11,"new","","Constructor",89,[[["l"]],["self"]]],[11,"rho","","Set rho",89,[[["f"]],[["error"],["result",["error"]]]]],[0,"condition","argmin::solver::linesearch","Acceptance conditions # References:",null,null],[3,"ArmijoCondition","argmin::solver::linesearch::condition","Armijo Condition",null,null],[3,"WolfeCondition","","Wolfe Condition",null,null],[3,"StrongWolfeCondition","","Strong Wolfe conditions",null,null],[3,"GoldsteinCondition","","Goldstein conditions",null,null],[8,"LineSearchCondition","","Needs to be implemented by everything that wants to be a…",null,null],[10,"eval","","Evaluate the condition",90,[[["t"],["self"],["f"]],["bool"]]],[10,"requires_cur_grad","","Indicates whether this condition requires the computation…",90,[[["self"]],["bool"]]],[11,"new","","Constructor",91,[[["f"]],[["error"],["result",["error"]]]]],[11,"new","","Constructor",92,[[["f"]],[["error"],["result",["error"]]]]],[11,"new","","Constructor",93,[[["f"]],[["error"],["result",["error"]]]]],[11,"new","","Constructor",94,[[["f"]],[["error"],["result",["error"]]]]],[0,"hagerzhang","argmin::solver::linesearch","Hager-Zhang line search algorithm * Hager-Zhang line search",null,null],[3,"HagerZhangLineSearch","argmin::solver::linesearch::hagerzhang","The Hager-Zhang line search is a method to find a step…",null,null],[11,"new","","Constructor",95,[[],["self"]]],[11,"delta","","set delta",95,[[["f"]],[["error"],["result",["error"]]]]],[11,"sigma","","set sigma",95,[[["f"]],[["error"],["result",["error"]]]]],[11,"epsilon","","set epsilon",95,[[["f"]],[["error"],["result",["error"]]]]],[11,"theta","","set theta",95,[[["f"]],[["error"],["result",["error"]]]]],[11,"gamma","","set gamma",95,[[["f"]],[["error"],["result",["error"]]]]],[11,"eta","","set eta",95,[[["f"]],[["error"],["result",["error"]]]]],[11,"alpha","","set alpha limits",95,[[["f"]],[["error"],["result",["error"]]]]],[0,"morethuente","argmin::solver::linesearch","More-Thuente line search algorithm * More-Thuente line…",null,null],[3,"MoreThuenteLineSearch","argmin::solver::linesearch::morethuente","The More-Thuente line search is a method to find a step…",null,null],[11,"new","","Constructor",96,[[],["self"]]],[11,"c","","Set c1 and c2 where 0 < c1 < c2 < 1.",96,[[["f"]],[["error"],["result",["error"]]]]],[11,"alpha","","set alpha limits",96,[[["f"]],[["error"],["result",["error"]]]]],[0,"neldermead","argmin::solver","References:",null,null],[3,"NelderMead","argmin::solver::neldermead","Nelder-Mead method",null,null],[11,"new","","Constructor",97,[[],["self"]]],[11,"with_initial_params","","Add initial parameters",97,[[["vec"]],["self"]]],[11,"sd_tolerance","","Set Sample standard deviation tolerance",97,[[["f"]],["self"]]],[11,"alpha","","set alpha",97,[[["f"]],[["error"],["result",["error"]]]]],[11,"gamma","","set gamma",97,[[["f"]],[["error"],["result",["error"]]]]],[11,"rho","","set rho",97,[[["f"]],[["error"],["result",["error"]]]]],[11,"sigma","","set sigma",97,[[["f"]],[["error"],["result",["error"]]]]],[0,"newton","argmin::solver","Newton Methods",null,null],[0,"newton_cg","argmin::solver::newton","Newton-CG method TODO: Stop when search direction is close…",null,null],[3,"NewtonCG","argmin::solver::newton::newton_cg","The Newton-CG method (also called truncated Newton method)…",null,null],[11,"new","","Constructor",98,[[["l"]],["self"]]],[11,"curvature_threshold","","Set curvature threshold",98,[[["f"]],["self"]]],[11,"with_tol","","Set tolerance for the stopping criterion based on cost…",98,[[["f"]],[["error"],["result",["error"]]]]],[0,"newton_method","argmin::solver::newton","Newton's method # References:",null,null],[3,"Newton","argmin::solver::newton::newton_method","Newton's method iteratively finds the stationary points of…",null,null],[11,"new","","Constructor",99,[[],["self"]]],[11,"set_gamma","","set gamma",99,[[["f"]],[["error"],["result",["error"]]]]],[0,"particleswarm","argmin::solver","References:",null,null],[3,"ParticleSwarm","argmin::solver::particleswarm","Particle Swarm Optimization (PSO)",null,null],[3,"Particle","","A single particle",null,null],[12,"position","","Position of particle",100,null],[12,"cost","","Cost of particle",100,null],[8,"Position","","Position",null,null],[11,"new","","Constructor",101,[[["f"],["usize"]],[["error"],["result",["error"]]]]],[0,"quasinewton","argmin::solver","Quasi-Newton methods",null,null],[0,"bfgs","argmin::solver::quasinewton","References:",null,null],[3,"BFGS","argmin::solver::quasinewton::bfgs","BFGS method",null,null],[11,"new","","Constructor",102,[[["l"],["h"]],["self"]]],[11,"with_tol_grad","","Sets tolerance for the stopping criterion based on the…",102,[[["f"]],["self"]]],[11,"with_tol_cost","","Sets tolerance for the stopping criterion based on the…",102,[[["f"]],["self"]]],[0,"dfp","argmin::solver::quasinewton","References:",null,null],[3,"DFP","argmin::solver::quasinewton::dfp","DFP method",null,null],[11,"new","","Constructor",103,[[["l"],["h"]],["self"]]],[11,"with_tol_grad","","Sets tolerance for the stopping criterion based on the…",103,[[["f"]],["self"]]],[0,"lbfgs","argmin::solver::quasinewton","References:",null,null],[3,"LBFGS","argmin::solver::quasinewton::lbfgs","L-BFGS method",null,null],[11,"new","","Constructor",104,[[["usize"],["l"]],["self"]]],[11,"with_tol_grad","","Sets tolerance for the stopping criterion based on the…",104,[[["f"]],["self"]]],[11,"with_tol_cost","","Sets tolerance for the stopping criterion based on the…",104,[[["f"]],["self"]]],[0,"sr1","argmin::solver::quasinewton","References:",null,null],[3,"SR1","argmin::solver::quasinewton::sr1","SR1 method (broken!)",null,null],[11,"new","","Constructor",105,[[["l"],["h"]],["self"]]],[11,"r","","Set r",105,[[["f"]],[["error"],["result",["error"]]]]],[11,"with_tol_grad","","Sets tolerance for the stopping criterion based on the…",105,[[["f"]],["self"]]],[11,"with_tol_cost","","Sets tolerance for the stopping criterion based on the…",105,[[["f"]],["self"]]],[0,"sr1_trustregion","argmin::solver::quasinewton","References:",null,null],[3,"SR1TrustRegion","argmin::solver::quasinewton::sr1_trustregion","SR1 Trust Region method",null,null],[11,"new","","Constructor",106,[[["r"]],["self"]]],[11,"hessian","","provide initial Hessian (if not provided, the algorithm…",106,[[["b"]],["self"]]],[11,"r","","Set r",106,[[["f"]],[["error"],["result",["error"]]]]],[11,"radius","","set radius",106,[[["f"]],["self"]]],[11,"eta","","Set eta",106,[[["f"]],[["error"],["result",["error"]]]]],[11,"with_tol_grad","","Sets tolerance for the stopping criterion based on the…",106,[[["f"]],["self"]]],[0,"simulatedannealing","argmin::solver","",null,null],[3,"SimulatedAnnealing","argmin::solver::simulatedannealing","Simulated Annealing",null,null],[4,"SATempFunc","","Temperature functions for Simulated Annealing.",null,null],[13,"TemperatureFast","","`t_i = t_init / i`",107,null],[13,"Boltzmann","","`t_i = t_init / ln(i)`",107,null],[13,"Exponential","","`t_i = t_init * x^i`",107,null],[11,"new","","Constructor",108,[[["f"]],[["error"],["result",["error"]]]]],[11,"temp_func","","Set temperature function to one of the options in…",108,[[["satempfunc"]],["self"]]],[11,"stall_accepted","","The optimization stops after there has been no accepted…",108,[[["u64"]],["self"]]],[11,"stall_best","","The optimization stops after there has been no new best…",108,[[["u64"]],["self"]]],[11,"reannealing_fixed","","Start reannealing after `iter` iterations",108,[[["u64"]],["self"]]],[11,"reannealing_accepted","","Start reannealing after no accepted solution has been…",108,[[["u64"]],["self"]]],[11,"reannealing_best","","Start reannealing after no new best solution has been…",108,[[["u64"]],["self"]]],[0,"trustregion","argmin::solver","Argmin Trust region methods",null,null],[5,"reduction_ratio","argmin::solver::trustregion","Computes reduction ratio",null,[[["argminfloat"]],["argminfloat"]]],[0,"cauchypoint","","Cauchy Point # References:",null,null],[3,"CauchyPoint","argmin::solver::trustregion::cauchypoint","The Cauchy point is the minimum of the quadratic…",null,null],[11,"new","","Constructor",109,[[],["self"]]],[0,"dogleg","argmin::solver::trustregion","Dogleg method # References:",null,null],[3,"Dogleg","argmin::solver::trustregion::dogleg","The Dogleg method computes the intersection of the trust…",null,null],[11,"new","","Constructor",110,[[],["self"]]],[0,"steihaug","argmin::solver::trustregion","Steihaug method # References:",null,null],[3,"Steihaug","argmin::solver::trustregion::steihaug","The Steihaug method is a conjugate gradients based…",null,null],[11,"new","","Constructor",111,[[],["self"]]],[11,"epsilon","","Set epsilon",111,[[["f"]],[["error"],["result",["error"]]]]],[11,"max_iters","","set maximum number of iterations",111,[[["u64"]],["self"]]],[0,"trustregion_method","argmin::solver::trustregion","Trust region solver # References:",null,null],[3,"TrustRegion","argmin::solver::trustregion::trustregion_method","The trust region method approximates the cost function…",null,null],[11,"new","","Constructor",112,[[["r"]],["self"]]],[11,"radius","","set radius",112,[[["f"]],["self"]]],[11,"max_radius","","Set maximum radius",112,[[["f"]],["self"]]],[11,"eta","","Set eta",112,[[["f"]],[["error"],["result",["error"]]]]],[14,"make_kv","argmin","Creates an `ArgminKV` at compile time in order to avoid…",null,null],[14,"check_param","","Release an `T` from an `Option<T>` if it is not `None`. If…",null,null],[14,"trait_bound","","Reuse a list of trait bounds by giving it a name, e.g.…",null,null],[11,"from","argmin::core","",113,[[["t"]],["t"]]],[11,"from","","",113,[[],["t"]]],[11,"into","","",113,[[],["u"]]],[11,"to_string","","",113,[[["self"]],["string"]]],[11,"try_from","","",113,[[["u"]],["result"]]],[11,"try_into","","",113,[[],["result"]]],[11,"borrow","","",113,[[["self"]],["t"]]],[11,"borrow_mut","","",113,[[["self"]],["t"]]],[11,"type_id","","",113,[[["self"]],["typeid"]]],[11,"vzip","","",113,[[],["v"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,[[["self"],["t"]]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"vzip","","",0,[[],["v"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,[[["self"],["t"]]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"vzip","","",1,[[],["v"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,[[["self"],["t"]]]],[11,"to_string","","",11,[[["self"]],["string"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"type_id","","",11,[[["self"]],["typeid"]]],[11,"vzip","","",11,[[],["v"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,[[["self"],["t"]]]],[11,"to_string","","",12,[[["self"]],["string"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"type_id","","",12,[[["self"]],["typeid"]]],[11,"vzip","","",12,[[],["v"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"into","","",13,[[],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,[[["self"],["t"]]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"type_id","","",13,[[["self"]],["typeid"]]],[11,"vzip","","",13,[[],["v"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"into","","",14,[[],["u"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,[[["self"],["t"]]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"type_id","","",14,[[["self"]],["typeid"]]],[11,"vzip","","",14,[[],["v"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"vzip","","",2,[[],["v"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"into","","",15,[[],["u"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"type_id","","",15,[[["self"]],["typeid"]]],[11,"vzip","","",15,[[],["v"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[],["u"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"type_id","","",16,[[["self"]],["typeid"]]],[11,"vzip","","",16,[[],["v"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,[[["self"],["t"]]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"type_id","","",17,[[["self"]],["typeid"]]],[11,"vzip","","",17,[[],["v"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,[[["self"],["t"]]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"vzip","","",3,[[],["v"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,[[["self"],["t"]]]],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"vzip","","",4,[[],["v"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[],["u"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,[[["self"],["t"]]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"type_id","","",18,[[["self"]],["typeid"]]],[11,"vzip","","",18,[[],["v"]]],[11,"from","","",42,[[["t"]],["t"]]],[11,"into","","",42,[[],["u"]]],[11,"to_owned","","",42,[[["self"]],["t"]]],[11,"clone_into","","",42,[[["self"],["t"]]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"try_into","","",42,[[],["result"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"type_id","","",42,[[["self"]],["typeid"]]],[11,"vzip","","",42,[[],["v"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"to_string","","",5,[[["self"]],["string"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"vzip","","",5,[[],["v"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,[[["self"],["t"]]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"vzip","","",6,[[],["v"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,[[["self"],["t"]]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"vzip","","",7,[[],["v"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,[[["self"],["t"]]]],[11,"to_string","","",8,[[["self"]],["string"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"type_id","","",8,[[["self"]],["typeid"]]],[11,"vzip","","",8,[[],["v"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,[[["self"],["t"]]]],[11,"to_string","","",9,[[["self"]],["string"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"vzip","","",9,[[],["v"]]],[11,"from","argmin::core::executor","",10,[[["t"]],["t"]]],[11,"into","","",10,[[],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,[[["self"],["t"]]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"type_id","","",10,[[["self"]],["typeid"]]],[11,"vzip","","",10,[[],["v"]]],[11,"from","argmin::prelude","",75,[[["t"]],["t"]]],[11,"into","","",75,[[],["u"]]],[11,"try_from","","",75,[[["u"]],["result"]]],[11,"try_into","","",75,[[],["result"]]],[11,"borrow","","",75,[[["self"]],["t"]]],[11,"borrow_mut","","",75,[[["self"]],["t"]]],[11,"type_id","","",75,[[["self"]],["typeid"]]],[11,"vzip","","",75,[[],["v"]]],[11,"from","","",76,[[["t"]],["t"]]],[11,"into","","",76,[[],["u"]]],[11,"to_string","","",76,[[["self"]],["string"]]],[11,"try_from","","",76,[[["u"]],["result"]]],[11,"try_into","","",76,[[],["result"]]],[11,"borrow","","",76,[[["self"]],["t"]]],[11,"borrow_mut","","",76,[[["self"]],["t"]]],[11,"type_id","","",76,[[["self"]],["typeid"]]],[11,"vzip","","",76,[[],["v"]]],[11,"from","argmin::solver::brent","",78,[[["t"]],["t"]]],[11,"into","","",78,[[],["u"]]],[11,"to_owned","","",78,[[["self"]],["t"]]],[11,"clone_into","","",78,[[["self"],["t"]]]],[11,"try_from","","",78,[[["u"]],["result"]]],[11,"try_into","","",78,[[],["result"]]],[11,"borrow","","",78,[[["self"]],["t"]]],[11,"borrow_mut","","",78,[[["self"]],["t"]]],[11,"type_id","","",78,[[["self"]],["typeid"]]],[11,"vzip","","",78,[[],["v"]]],[11,"from","","",77,[[["t"]],["t"]]],[11,"into","","",77,[[],["u"]]],[11,"to_string","","",77,[[["self"]],["string"]]],[11,"try_from","","",77,[[["u"]],["result"]]],[11,"try_into","","",77,[[],["result"]]],[11,"borrow","","",77,[[["self"]],["t"]]],[11,"borrow_mut","","",77,[[["self"]],["t"]]],[11,"type_id","","",77,[[["self"]],["typeid"]]],[11,"vzip","","",77,[[],["v"]]],[11,"from","argmin::solver::conjugategradient::cg","",79,[[["t"]],["t"]]],[11,"into","","",79,[[],["u"]]],[11,"to_owned","","",79,[[["self"]],["t"]]],[11,"clone_into","","",79,[[["self"],["t"]]]],[11,"try_from","","",79,[[["u"]],["result"]]],[11,"try_into","","",79,[[],["result"]]],[11,"borrow","","",79,[[["self"]],["t"]]],[11,"borrow_mut","","",79,[[["self"]],["t"]]],[11,"type_id","","",79,[[["self"]],["typeid"]]],[11,"vzip","","",79,[[],["v"]]],[11,"from","argmin::solver::conjugategradient::nonlinear_cg","",80,[[["t"]],["t"]]],[11,"into","","",80,[[],["u"]]],[11,"to_owned","","",80,[[["self"]],["t"]]],[11,"clone_into","","",80,[[["self"],["t"]]]],[11,"try_from","","",80,[[["u"]],["result"]]],[11,"try_into","","",80,[[],["result"]]],[11,"borrow","","",80,[[["self"]],["t"]]],[11,"borrow_mut","","",80,[[["self"]],["t"]]],[11,"type_id","","",80,[[["self"]],["typeid"]]],[11,"vzip","","",80,[[],["v"]]],[11,"from","argmin::solver::conjugategradient::beta","",81,[[["t"]],["t"]]],[11,"into","","",81,[[],["u"]]],[11,"to_owned","","",81,[[["self"]],["t"]]],[11,"clone_into","","",81,[[["self"],["t"]]]],[11,"try_from","","",81,[[["u"]],["result"]]],[11,"try_into","","",81,[[],["result"]]],[11,"borrow","","",81,[[["self"]],["t"]]],[11,"borrow_mut","","",81,[[["self"]],["t"]]],[11,"type_id","","",81,[[["self"]],["typeid"]]],[11,"vzip","","",81,[[],["v"]]],[11,"from","","",82,[[["t"]],["t"]]],[11,"into","","",82,[[],["u"]]],[11,"to_owned","","",82,[[["self"]],["t"]]],[11,"clone_into","","",82,[[["self"],["t"]]]],[11,"try_from","","",82,[[["u"]],["result"]]],[11,"try_into","","",82,[[],["result"]]],[11,"borrow","","",82,[[["self"]],["t"]]],[11,"borrow_mut","","",82,[[["self"]],["t"]]],[11,"type_id","","",82,[[["self"]],["typeid"]]],[11,"vzip","","",82,[[],["v"]]],[11,"from","","",83,[[["t"]],["t"]]],[11,"into","","",83,[[],["u"]]],[11,"to_owned","","",83,[[["self"]],["t"]]],[11,"clone_into","","",83,[[["self"],["t"]]]],[11,"try_from","","",83,[[["u"]],["result"]]],[11,"try_into","","",83,[[],["result"]]],[11,"borrow","","",83,[[["self"]],["t"]]],[11,"borrow_mut","","",83,[[["self"]],["t"]]],[11,"type_id","","",83,[[["self"]],["typeid"]]],[11,"vzip","","",83,[[],["v"]]],[11,"from","","",84,[[["t"]],["t"]]],[11,"into","","",84,[[],["u"]]],[11,"to_owned","","",84,[[["self"]],["t"]]],[11,"clone_into","","",84,[[["self"],["t"]]]],[11,"try_from","","",84,[[["u"]],["result"]]],[11,"try_into","","",84,[[],["result"]]],[11,"borrow","","",84,[[["self"]],["t"]]],[11,"borrow_mut","","",84,[[["self"]],["t"]]],[11,"type_id","","",84,[[["self"]],["typeid"]]],[11,"vzip","","",84,[[],["v"]]],[11,"from","argmin::solver::gaussnewton::gaussnewton_linesearch","",85,[[["t"]],["t"]]],[11,"into","","",85,[[],["u"]]],[11,"to_owned","","",85,[[["self"]],["t"]]],[11,"clone_into","","",85,[[["self"],["t"]]]],[11,"try_from","","",85,[[["u"]],["result"]]],[11,"try_into","","",85,[[],["result"]]],[11,"borrow","","",85,[[["self"]],["t"]]],[11,"borrow_mut","","",85,[[["self"]],["t"]]],[11,"type_id","","",85,[[["self"]],["typeid"]]],[11,"vzip","","",85,[[],["v"]]],[11,"from","argmin::solver::gaussnewton::gaussnewton_method","",86,[[["t"]],["t"]]],[11,"into","","",86,[[],["u"]]],[11,"to_owned","","",86,[[["self"]],["t"]]],[11,"clone_into","","",86,[[["self"],["t"]]]],[11,"try_from","","",86,[[["u"]],["result"]]],[11,"try_into","","",86,[[],["result"]]],[11,"borrow","","",86,[[["self"]],["t"]]],[11,"borrow_mut","","",86,[[["self"]],["t"]]],[11,"type_id","","",86,[[["self"]],["typeid"]]],[11,"vzip","","",86,[[],["v"]]],[11,"from","argmin::solver::gradientdescent::steepestdescent","",87,[[["t"]],["t"]]],[11,"into","","",87,[[],["u"]]],[11,"to_owned","","",87,[[["self"]],["t"]]],[11,"clone_into","","",87,[[["self"],["t"]]]],[11,"try_from","","",87,[[["u"]],["result"]]],[11,"try_into","","",87,[[],["result"]]],[11,"borrow","","",87,[[["self"]],["t"]]],[11,"borrow_mut","","",87,[[["self"]],["t"]]],[11,"type_id","","",87,[[["self"]],["typeid"]]],[11,"vzip","","",87,[[],["v"]]],[11,"from","argmin::solver::landweber","",88,[[["t"]],["t"]]],[11,"into","","",88,[[],["u"]]],[11,"to_owned","","",88,[[["self"]],["t"]]],[11,"clone_into","","",88,[[["self"],["t"]]]],[11,"try_from","","",88,[[["u"]],["result"]]],[11,"try_into","","",88,[[],["result"]]],[11,"borrow","","",88,[[["self"]],["t"]]],[11,"borrow_mut","","",88,[[["self"]],["t"]]],[11,"type_id","","",88,[[["self"]],["typeid"]]],[11,"vzip","","",88,[[],["v"]]],[11,"from","argmin::solver::linesearch::backtracking","",89,[[["t"]],["t"]]],[11,"into","","",89,[[],["u"]]],[11,"to_owned","","",89,[[["self"]],["t"]]],[11,"clone_into","","",89,[[["self"],["t"]]]],[11,"try_from","","",89,[[["u"]],["result"]]],[11,"try_into","","",89,[[],["result"]]],[11,"borrow","","",89,[[["self"]],["t"]]],[11,"borrow_mut","","",89,[[["self"]],["t"]]],[11,"type_id","","",89,[[["self"]],["typeid"]]],[11,"vzip","","",89,[[],["v"]]],[11,"from","argmin::solver::linesearch::condition","",91,[[["t"]],["t"]]],[11,"into","","",91,[[],["u"]]],[11,"to_owned","","",91,[[["self"]],["t"]]],[11,"clone_into","","",91,[[["self"],["t"]]]],[11,"try_from","","",91,[[["u"]],["result"]]],[11,"try_into","","",91,[[],["result"]]],[11,"borrow","","",91,[[["self"]],["t"]]],[11,"borrow_mut","","",91,[[["self"]],["t"]]],[11,"type_id","","",91,[[["self"]],["typeid"]]],[11,"vzip","","",91,[[],["v"]]],[11,"from","","",92,[[["t"]],["t"]]],[11,"into","","",92,[[],["u"]]],[11,"to_owned","","",92,[[["self"]],["t"]]],[11,"clone_into","","",92,[[["self"],["t"]]]],[11,"try_from","","",92,[[["u"]],["result"]]],[11,"try_into","","",92,[[],["result"]]],[11,"borrow","","",92,[[["self"]],["t"]]],[11,"borrow_mut","","",92,[[["self"]],["t"]]],[11,"type_id","","",92,[[["self"]],["typeid"]]],[11,"vzip","","",92,[[],["v"]]],[11,"from","","",93,[[["t"]],["t"]]],[11,"into","","",93,[[],["u"]]],[11,"to_owned","","",93,[[["self"]],["t"]]],[11,"clone_into","","",93,[[["self"],["t"]]]],[11,"try_from","","",93,[[["u"]],["result"]]],[11,"try_into","","",93,[[],["result"]]],[11,"borrow","","",93,[[["self"]],["t"]]],[11,"borrow_mut","","",93,[[["self"]],["t"]]],[11,"type_id","","",93,[[["self"]],["typeid"]]],[11,"vzip","","",93,[[],["v"]]],[11,"from","","",94,[[["t"]],["t"]]],[11,"into","","",94,[[],["u"]]],[11,"to_owned","","",94,[[["self"]],["t"]]],[11,"clone_into","","",94,[[["self"],["t"]]]],[11,"try_from","","",94,[[["u"]],["result"]]],[11,"try_into","","",94,[[],["result"]]],[11,"borrow","","",94,[[["self"]],["t"]]],[11,"borrow_mut","","",94,[[["self"]],["t"]]],[11,"type_id","","",94,[[["self"]],["typeid"]]],[11,"vzip","","",94,[[],["v"]]],[11,"from","argmin::solver::linesearch::hagerzhang","",95,[[["t"]],["t"]]],[11,"into","","",95,[[],["u"]]],[11,"to_owned","","",95,[[["self"]],["t"]]],[11,"clone_into","","",95,[[["self"],["t"]]]],[11,"try_from","","",95,[[["u"]],["result"]]],[11,"try_into","","",95,[[],["result"]]],[11,"borrow","","",95,[[["self"]],["t"]]],[11,"borrow_mut","","",95,[[["self"]],["t"]]],[11,"type_id","","",95,[[["self"]],["typeid"]]],[11,"vzip","","",95,[[],["v"]]],[11,"from","argmin::solver::linesearch::morethuente","",96,[[["t"]],["t"]]],[11,"into","","",96,[[],["u"]]],[11,"to_owned","","",96,[[["self"]],["t"]]],[11,"clone_into","","",96,[[["self"],["t"]]]],[11,"try_from","","",96,[[["u"]],["result"]]],[11,"try_into","","",96,[[],["result"]]],[11,"borrow","","",96,[[["self"]],["t"]]],[11,"borrow_mut","","",96,[[["self"]],["t"]]],[11,"type_id","","",96,[[["self"]],["typeid"]]],[11,"vzip","","",96,[[],["v"]]],[11,"from","argmin::solver::neldermead","",97,[[["t"]],["t"]]],[11,"into","","",97,[[],["u"]]],[11,"to_owned","","",97,[[["self"]],["t"]]],[11,"clone_into","","",97,[[["self"],["t"]]]],[11,"try_from","","",97,[[["u"]],["result"]]],[11,"try_into","","",97,[[],["result"]]],[11,"borrow","","",97,[[["self"]],["t"]]],[11,"borrow_mut","","",97,[[["self"]],["t"]]],[11,"type_id","","",97,[[["self"]],["typeid"]]],[11,"vzip","","",97,[[],["v"]]],[11,"from","argmin::solver::newton::newton_cg","",98,[[["t"]],["t"]]],[11,"into","","",98,[[],["u"]]],[11,"to_owned","","",98,[[["self"]],["t"]]],[11,"clone_into","","",98,[[["self"],["t"]]]],[11,"try_from","","",98,[[["u"]],["result"]]],[11,"try_into","","",98,[[],["result"]]],[11,"borrow","","",98,[[["self"]],["t"]]],[11,"borrow_mut","","",98,[[["self"]],["t"]]],[11,"type_id","","",98,[[["self"]],["typeid"]]],[11,"vzip","","",98,[[],["v"]]],[11,"from","argmin::solver::newton::newton_method","",99,[[["t"]],["t"]]],[11,"into","","",99,[[],["u"]]],[11,"to_owned","","",99,[[["self"]],["t"]]],[11,"clone_into","","",99,[[["self"],["t"]]]],[11,"try_from","","",99,[[["u"]],["result"]]],[11,"try_into","","",99,[[],["result"]]],[11,"borrow","","",99,[[["self"]],["t"]]],[11,"borrow_mut","","",99,[[["self"]],["t"]]],[11,"type_id","","",99,[[["self"]],["typeid"]]],[11,"vzip","","",99,[[],["v"]]],[11,"from","argmin::solver::particleswarm","",101,[[["t"]],["t"]]],[11,"into","","",101,[[],["u"]]],[11,"try_from","","",101,[[["u"]],["result"]]],[11,"try_into","","",101,[[],["result"]]],[11,"borrow","","",101,[[["self"]],["t"]]],[11,"borrow_mut","","",101,[[["self"]],["t"]]],[11,"type_id","","",101,[[["self"]],["typeid"]]],[11,"vzip","","",101,[[],["v"]]],[11,"from","","",100,[[["t"]],["t"]]],[11,"into","","",100,[[],["u"]]],[11,"to_owned","","",100,[[["self"]],["t"]]],[11,"clone_into","","",100,[[["self"],["t"]]]],[11,"try_from","","",100,[[["u"]],["result"]]],[11,"try_into","","",100,[[],["result"]]],[11,"borrow","","",100,[[["self"]],["t"]]],[11,"borrow_mut","","",100,[[["self"]],["t"]]],[11,"type_id","","",100,[[["self"]],["typeid"]]],[11,"vzip","","",100,[[],["v"]]],[11,"from","argmin::solver::quasinewton::bfgs","",102,[[["t"]],["t"]]],[11,"into","","",102,[[],["u"]]],[11,"to_owned","","",102,[[["self"]],["t"]]],[11,"clone_into","","",102,[[["self"],["t"]]]],[11,"try_from","","",102,[[["u"]],["result"]]],[11,"try_into","","",102,[[],["result"]]],[11,"borrow","","",102,[[["self"]],["t"]]],[11,"borrow_mut","","",102,[[["self"]],["t"]]],[11,"type_id","","",102,[[["self"]],["typeid"]]],[11,"vzip","","",102,[[],["v"]]],[11,"from","argmin::solver::quasinewton::dfp","",103,[[["t"]],["t"]]],[11,"into","","",103,[[],["u"]]],[11,"to_owned","","",103,[[["self"]],["t"]]],[11,"clone_into","","",103,[[["self"],["t"]]]],[11,"try_from","","",103,[[["u"]],["result"]]],[11,"try_into","","",103,[[],["result"]]],[11,"borrow","","",103,[[["self"]],["t"]]],[11,"borrow_mut","","",103,[[["self"]],["t"]]],[11,"type_id","","",103,[[["self"]],["typeid"]]],[11,"vzip","","",103,[[],["v"]]],[11,"from","argmin::solver::quasinewton::lbfgs","",104,[[["t"]],["t"]]],[11,"into","","",104,[[],["u"]]],[11,"to_owned","","",104,[[["self"]],["t"]]],[11,"clone_into","","",104,[[["self"],["t"]]]],[11,"try_from","","",104,[[["u"]],["result"]]],[11,"try_into","","",104,[[],["result"]]],[11,"borrow","","",104,[[["self"]],["t"]]],[11,"borrow_mut","","",104,[[["self"]],["t"]]],[11,"type_id","","",104,[[["self"]],["typeid"]]],[11,"vzip","","",104,[[],["v"]]],[11,"from","argmin::solver::quasinewton::sr1","",105,[[["t"]],["t"]]],[11,"into","","",105,[[],["u"]]],[11,"to_owned","","",105,[[["self"]],["t"]]],[11,"clone_into","","",105,[[["self"],["t"]]]],[11,"try_from","","",105,[[["u"]],["result"]]],[11,"try_into","","",105,[[],["result"]]],[11,"borrow","","",105,[[["self"]],["t"]]],[11,"borrow_mut","","",105,[[["self"]],["t"]]],[11,"type_id","","",105,[[["self"]],["typeid"]]],[11,"vzip","","",105,[[],["v"]]],[11,"from","argmin::solver::quasinewton::sr1_trustregion","",106,[[["t"]],["t"]]],[11,"into","","",106,[[],["u"]]],[11,"to_owned","","",106,[[["self"]],["t"]]],[11,"clone_into","","",106,[[["self"],["t"]]]],[11,"try_from","","",106,[[["u"]],["result"]]],[11,"try_into","","",106,[[],["result"]]],[11,"borrow","","",106,[[["self"]],["t"]]],[11,"borrow_mut","","",106,[[["self"]],["t"]]],[11,"type_id","","",106,[[["self"]],["typeid"]]],[11,"vzip","","",106,[[],["v"]]],[11,"from","argmin::solver::simulatedannealing","",108,[[["t"]],["t"]]],[11,"into","","",108,[[],["u"]]],[11,"to_owned","","",108,[[["self"]],["t"]]],[11,"clone_into","","",108,[[["self"],["t"]]]],[11,"try_from","","",108,[[["u"]],["result"]]],[11,"try_into","","",108,[[],["result"]]],[11,"borrow","","",108,[[["self"]],["t"]]],[11,"borrow_mut","","",108,[[["self"]],["t"]]],[11,"type_id","","",108,[[["self"]],["typeid"]]],[11,"vzip","","",108,[[],["v"]]],[11,"from","","",107,[[["t"]],["t"]]],[11,"into","","",107,[[],["u"]]],[11,"to_owned","","",107,[[["self"]],["t"]]],[11,"clone_into","","",107,[[["self"],["t"]]]],[11,"try_from","","",107,[[["u"]],["result"]]],[11,"try_into","","",107,[[],["result"]]],[11,"borrow","","",107,[[["self"]],["t"]]],[11,"borrow_mut","","",107,[[["self"]],["t"]]],[11,"type_id","","",107,[[["self"]],["typeid"]]],[11,"vzip","","",107,[[],["v"]]],[11,"from","argmin::solver::trustregion::cauchypoint","",109,[[["t"]],["t"]]],[11,"into","","",109,[[],["u"]]],[11,"to_owned","","",109,[[["self"]],["t"]]],[11,"clone_into","","",109,[[["self"],["t"]]]],[11,"try_from","","",109,[[["u"]],["result"]]],[11,"try_into","","",109,[[],["result"]]],[11,"borrow","","",109,[[["self"]],["t"]]],[11,"borrow_mut","","",109,[[["self"]],["t"]]],[11,"type_id","","",109,[[["self"]],["typeid"]]],[11,"vzip","","",109,[[],["v"]]],[11,"from","argmin::solver::trustregion::dogleg","",110,[[["t"]],["t"]]],[11,"into","","",110,[[],["u"]]],[11,"to_owned","","",110,[[["self"]],["t"]]],[11,"clone_into","","",110,[[["self"],["t"]]]],[11,"try_from","","",110,[[["u"]],["result"]]],[11,"try_into","","",110,[[],["result"]]],[11,"borrow","","",110,[[["self"]],["t"]]],[11,"borrow_mut","","",110,[[["self"]],["t"]]],[11,"type_id","","",110,[[["self"]],["typeid"]]],[11,"vzip","","",110,[[],["v"]]],[11,"from","argmin::solver::trustregion::steihaug","",111,[[["t"]],["t"]]],[11,"into","","",111,[[],["u"]]],[11,"to_owned","","",111,[[["self"]],["t"]]],[11,"clone_into","","",111,[[["self"],["t"]]]],[11,"try_from","","",111,[[["u"]],["result"]]],[11,"try_into","","",111,[[],["result"]]],[11,"borrow","","",111,[[["self"]],["t"]]],[11,"borrow_mut","","",111,[[["self"]],["t"]]],[11,"type_id","","",111,[[["self"]],["typeid"]]],[11,"vzip","","",111,[[],["v"]]],[11,"from","argmin::solver::trustregion::trustregion_method","",112,[[["t"]],["t"]]],[11,"into","","",112,[[],["u"]]],[11,"to_owned","","",112,[[["self"]],["t"]]],[11,"clone_into","","",112,[[["self"],["t"]]]],[11,"try_from","","",112,[[["u"]],["result"]]],[11,"try_into","","",112,[[],["result"]]],[11,"borrow","","",112,[[["self"]],["t"]]],[11,"borrow_mut","","",112,[[["self"]],["t"]]],[11,"type_id","","",112,[[["self"]],["typeid"]]],[11,"vzip","","",112,[[],["v"]]],[11,"fmt","argmin::prelude","",76,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",76,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",75,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","argmin::core","",113,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"deref","","",113,[[["self"]]]],[11,"as_ref","","",113,[[["self"]],["error"]]],[11,"as_ref","","",113,[[["self"]],["error"]]],[11,"from","","",113,[[["e"]],["error"]]],[11,"fmt","","",113,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"drop","","",113,[[["self"]]]],[11,"deref_mut","","",113,[[["self"]]]],[11,"observe_iter","","",13,[[["self"],["iterstate"],["argminkv"]],[["result",["error"]],["error"]]]],[11,"observe_init","","Log general info",14,[[["str"],["argminkv"],["self"]],[["result",["error"]],["error"]]]],[11,"observe_iter","","This should be used to log iteration data only (because…",14,[[["self"],["iterstate"],["argminkv"]],[["result",["error"]],["error"]]]],[11,"observe_iter","","",15,[[["self"],["iterstate"],["argminkv"]],[["result",["error"]],["error"]]]],[11,"observe_init","","Initial observation This is called after the…",17,[[["str"],["argminkv"],["self"]],[["result",["error"]],["error"]]]],[11,"observe_iter","","This is called after every iteration and gets the current…",17,[[["self"],["iterstate"],["argminkv"]],[["result",["error"]],["error"]]]],[11,"apply","","Do nothing, really.",11,[[["self"]],[["error"],["result",["error"]]]]],[11,"gradient","","Do nothing, really.",11,[[["self"]],[["error"],["result",["error"]]]]],[11,"hessian","","Do nothing, really.",11,[[["self"]],[["error"],["result",["error"]]]]],[11,"modify","","Do nothing, really.",11,[[["self"]],[["error"],["result",["error"]]]]],[11,"apply","","Do nothing, really.",12,[[["self"]],[["error"],["result",["error"]]]]],[11,"gradient","","Do nothing, really.",12,[[["self"]],[["error"],["result",["error"]]]]],[11,"hessian","","Do nothing, really.",12,[[["self"]],[["error"],["result",["error"]]]]],[11,"modify","","Do nothing, really.",12,[[["self"],["f64"]],[["error"],["result",["error"]]]]],[11,"apply","","",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"gradient","","",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"hessian","","",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"jacobian","","",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"modify","","",3,[[["self"]],[["error"],["result",["error"]]]]],[11,"init","argmin::solver::brent","",78,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",78,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"init","argmin::solver::conjugategradient::cg","",79,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","Perform one iteration of CG algorithm",79,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"init","argmin::solver::conjugategradient::nonlinear_cg","",80,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",80,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"next_iter","argmin::solver::gaussnewton::gaussnewton_linesearch","",85,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",85,[[["self"],["iterstate"]],["terminationreason"]]],[11,"next_iter","argmin::solver::gaussnewton::gaussnewton_method","",86,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",86,[[["self"],["iterstate"]],["terminationreason"]]],[11,"next_iter","argmin::solver::gradientdescent::steepestdescent","",87,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"next_iter","argmin::solver::landweber","",88,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"init","argmin::solver::linesearch::backtracking","",89,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",89,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",89,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::linesearch::hagerzhang","",95,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",95,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",95,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::linesearch::morethuente","",96,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",96,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"init","argmin::solver::neldermead","",97,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",97,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",97,[[["self"],["iterstate"]],["terminationreason"]]],[11,"next_iter","argmin::solver::newton::newton_cg","",98,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",98,[[["self"],["iterstate"]],["terminationreason"]]],[11,"next_iter","argmin::solver::newton::newton_method","",99,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"init","argmin::solver::particleswarm","",101,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","Perform one iteration of algorithm",101,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"init","argmin::solver::quasinewton::bfgs","",102,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",102,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",102,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::quasinewton::dfp","",103,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",103,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",103,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::quasinewton::lbfgs","",104,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",104,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",104,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::quasinewton::sr1","",105,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",105,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",105,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::quasinewton::sr1_trustregion","",106,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",106,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",106,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::simulatedannealing","",108,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","Perform one iteration of SA algorithm",108,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",108,[[["self"],["iterstate"]],["terminationreason"]]],[11,"next_iter","argmin::solver::trustregion::cauchypoint","",109,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",109,[[["self"],["iterstate"]],["terminationreason"]]],[11,"next_iter","argmin::solver::trustregion::dogleg","",110,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",110,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::trustregion::steihaug","",111,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",111,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",111,[[["self"],["iterstate"]],["terminationreason"]]],[11,"init","argmin::solver::trustregion::trustregion_method","",112,[[["opwrapper"],["self"],["iterstate"]],[["error"],["result",["option","error"]],["option",["argminiterdata"]]]]],[11,"next_iter","","",112,[[["opwrapper"],["self"],["iterstate"]],[["error"],["argminiterdata"],["result",["argminiterdata","error"]]]]],[11,"terminate","","",112,[[["self"],["iterstate"]],["terminationreason"]]],[11,"set_search_direction","argmin::solver::linesearch::backtracking","Set search direction",89,[[["self"],["p"]]]],[11,"set_init_alpha","","Set initial alpha value",89,[[["self"],["f"]],[["result",["error"]],["error"]]]],[11,"set_search_direction","argmin::solver::linesearch::hagerzhang","Set search direction",95,[[["self"],["p"]]]],[11,"set_init_alpha","","Set initial alpha value",95,[[["self"],["f"]],[["result",["error"]],["error"]]]],[11,"set_search_direction","argmin::solver::linesearch::morethuente","Set search direction",96,[[["self"],["p"]]]],[11,"set_init_alpha","","Set initial alpha value",96,[[["self"],["f"]],[["result",["error"]],["error"]]]],[11,"set_radius","argmin::solver::trustregion::cauchypoint","",109,[[["self"],["f"]]]],[11,"set_radius","argmin::solver::trustregion::dogleg","",110,[[["self"],["f"]]]],[11,"set_radius","argmin::solver::trustregion::steihaug","",111,[[["self"],["f"]]]],[11,"update","argmin::solver::conjugategradient::beta","",81,[[["t"],["self"]],["f"]]],[11,"update","","",82,[[["t"],["self"]],["f"]]],[11,"update","","",83,[[["t"],["self"]],["f"]]],[11,"update","","",84,[[["t"],["self"]],["f"]]],[11,"eval","argmin::solver::linesearch::condition","",91,[[["t"],["self"],["f"]],["bool"]]],[11,"requires_cur_grad","","",91,[[["self"]],["bool"]]],[11,"eval","","",92,[[["t"],["self"],["f"]],["bool"]]],[11,"requires_cur_grad","","",92,[[["self"]],["bool"]]],[11,"eval","","",93,[[["t"],["self"],["f"]],["bool"]]],[11,"requires_cur_grad","","",93,[[["self"]],["bool"]]],[11,"eval","","",94,[[["t"],["self"],["f"]],["bool"]]],[11,"requires_cur_grad","","",94,[[["self"]],["bool"]]],[11,"from","argmin::core","",2,[[["argminkv"]],["argminslogkv"]]],[11,"extend","","",1,[[["self"],["intoiterator"]]]],[11,"clone","argmin::core::executor","",10,[[["self"]],["executor"]]],[11,"clone","argmin::core","",0,[[["self"]],["iterstate"]]],[11,"clone","","",1,[[["self"]],["argminkv"]]],[11,"clone","","",11,[[["self"]],["nooperator"]]],[11,"clone","","",12,[[["self"]],["minimalnooperator"]]],[11,"clone","","",6,[[["self"]],["writetofileserializer"]]],[11,"clone","","",13,[[["self"]],["writetofile"]]],[11,"clone","","",14,[[["self"]],["argminsloglogger"]]],[11,"clone","","",17,[[["self"]],["observer"]]],[11,"clone","","",7,[[["self"]],["observermode"]]],[11,"clone","","",3,[[["self"]],["opwrapper"]]],[11,"clone","","",4,[[["self"]],["argminresult"]]],[11,"clone","","",8,[[["self"]],["checkpointmode"]]],[11,"clone","","",18,[[["self"]],["argmincheckpoint"]]],[11,"clone","","",9,[[["self"]],["terminationreason"]]],[11,"clone","","",42,[[["self"]],["argminiterdata"]]],[11,"clone","argmin::solver::brent","",78,[[["self"]],["brent"]]],[11,"clone","argmin::solver::conjugategradient::cg","",79,[[["self"]],["conjugategradient"]]],[11,"clone","argmin::solver::conjugategradient::nonlinear_cg","",80,[[["self"]],["nonlinearconjugategradient"]]],[11,"clone","argmin::solver::conjugategradient::beta","",81,[[["self"]],["fletcherreeves"]]],[11,"clone","","",82,[[["self"]],["polakribiere"]]],[11,"clone","","",83,[[["self"]],["polakribiereplus"]]],[11,"clone","","",84,[[["self"]],["hestenesstiefel"]]],[11,"clone","argmin::solver::gaussnewton::gaussnewton_linesearch","",85,[[["self"]],["gaussnewtonls"]]],[11,"clone","argmin::solver::gaussnewton::gaussnewton_method","",86,[[["self"]],["gaussnewton"]]],[11,"clone","argmin::solver::gradientdescent::steepestdescent","",87,[[["self"]],["steepestdescent"]]],[11,"clone","argmin::solver::landweber","",88,[[["self"]],["landweber"]]],[11,"clone","argmin::solver::linesearch::backtracking","",89,[[["self"]],["backtrackinglinesearch"]]],[11,"clone","argmin::solver::linesearch::condition","",91,[[["self"]],["armijocondition"]]],[11,"clone","","",92,[[["self"]],["wolfecondition"]]],[11,"clone","","",93,[[["self"]],["strongwolfecondition"]]],[11,"clone","","",94,[[["self"]],["goldsteincondition"]]],[11,"clone","argmin::solver::linesearch::hagerzhang","",95,[[["self"]],["hagerzhanglinesearch"]]],[11,"clone","argmin::solver::linesearch::morethuente","",96,[[["self"]],["morethuentelinesearch"]]],[11,"clone","argmin::solver::neldermead","",97,[[["self"]],["neldermead"]]],[11,"clone","argmin::solver::newton::newton_cg","",98,[[["self"]],["newtoncg"]]],[11,"clone","argmin::solver::newton::newton_method","",99,[[["self"]],["newton"]]],[11,"clone","argmin::solver::particleswarm","",100,[[["self"]],["particle"]]],[11,"clone","argmin::solver::quasinewton::bfgs","",102,[[["self"]],["bfgs"]]],[11,"clone","argmin::solver::quasinewton::dfp","",103,[[["self"]],["dfp"]]],[11,"clone","argmin::solver::quasinewton::lbfgs","",104,[[["self"]],["lbfgs"]]],[11,"clone","argmin::solver::quasinewton::sr1","",105,[[["self"]],["sr1"]]],[11,"clone","argmin::solver::quasinewton::sr1_trustregion","",106,[[["self"]],["sr1trustregion"]]],[11,"clone","argmin::solver::simulatedannealing","",107,[[["self"]],["satempfunc"]]],[11,"clone","","",108,[[["self"]],["simulatedannealing"]]],[11,"clone","argmin::solver::trustregion::cauchypoint","",109,[[["self"]],["cauchypoint"]]],[11,"clone","argmin::solver::trustregion::dogleg","",110,[[["self"]],["dogleg"]]],[11,"clone","argmin::solver::trustregion::steihaug","",111,[[["self"]],["steihaug"]]],[11,"clone","argmin::solver::trustregion::trustregion_method","",112,[[["self"]],["trustregion"]]],[11,"default","argmin::core","",0,[[],["self"]]],[11,"default","","",1,[[],["argminkv"]]],[11,"default","","",11,[[],["nooperator"]]],[11,"default","","",12,[[],["minimalnooperator"]]],[11,"default","","",6,[[],["self"]]],[11,"default","","",17,[[],["observer"]]],[11,"default","","The default is `Always`",7,[[],["observermode"]]],[11,"default","","",3,[[],["opwrapper"]]],[11,"default","","",8,[[],["checkpointmode"]]],[11,"default","","",18,[[],["argmincheckpoint"]]],[11,"default","","",9,[[],["self"]]],[11,"default","","",42,[[],["argminiterdata"]]],[11,"default","argmin::solver::conjugategradient::beta","",81,[[],["fletcherreeves"]]],[11,"default","","",82,[[],["polakribiere"]]],[11,"default","","",83,[[],["polakribiereplus"]]],[11,"default","","",84,[[],["hestenesstiefel"]]],[11,"default","argmin::solver::gaussnewton::gaussnewton_method","",86,[[],["gaussnewton"]]],[11,"default","argmin::solver::linesearch::condition","",91,[[],["armijocondition"]]],[11,"default","","",92,[[],["wolfecondition"]]],[11,"default","","",93,[[],["strongwolfecondition"]]],[11,"default","","",94,[[],["goldsteincondition"]]],[11,"default","argmin::solver::linesearch::hagerzhang","",95,[[],["self"]]],[11,"default","argmin::solver::linesearch::morethuente","",96,[[],["self"]]],[11,"default","argmin::solver::neldermead","",97,[[],["neldermead"]]],[11,"default","argmin::solver::newton::newton_method","",99,[[],["newton"]]],[11,"default","argmin::solver::simulatedannealing","",107,[[],["self"]]],[11,"default","argmin::solver::trustregion::cauchypoint","",109,[[],["cauchypoint"]]],[11,"default","argmin::solver::trustregion::dogleg","",110,[[],["dogleg"]]],[11,"default","argmin::solver::trustregion::steihaug","",111,[[],["steihaug"]]],[11,"cmp","argmin::core","",1,[[["argminkv"],["self"]],["ordering"]]],[11,"cmp","","",11,[[["nooperator"],["self"]],["ordering"]]],[11,"cmp","","",12,[[["minimalnooperator"],["self"]],["ordering"]]],[11,"cmp","","",6,[[["writetofileserializer"],["self"]],["ordering"]]],[11,"cmp","","",13,[[["self"],["writetofile"]],["ordering"]]],[11,"cmp","","",7,[[["self"],["observermode"]],["ordering"]]],[11,"cmp","","",4,[[["self"],["argminresult"]],["ordering"]]],[11,"cmp","","",8,[[["self"],["checkpointmode"]],["ordering"]]],[11,"cmp","","",18,[[["self"],["argmincheckpoint"]],["ordering"]]],[11,"cmp","","",9,[[["self"],["terminationreason"]],["ordering"]]],[11,"cmp","argmin::solver::conjugategradient::beta","",81,[[["self"],["fletcherreeves"]],["ordering"]]],[11,"cmp","","",82,[[["polakribiere"],["self"]],["ordering"]]],[11,"cmp","","",83,[[["self"],["polakribiereplus"]],["ordering"]]],[11,"cmp","","",84,[[["hestenesstiefel"],["self"]],["ordering"]]],[11,"eq","argmin::core","",1,[[["argminkv"],["self"]],["bool"]]],[11,"ne","","",1,[[["argminkv"],["self"]],["bool"]]],[11,"eq","","",11,[[["nooperator"],["self"]],["bool"]]],[11,"ne","","",11,[[["nooperator"],["self"]],["bool"]]],[11,"eq","","",12,[[["minimalnooperator"],["self"]],["bool"]]],[11,"eq","","",6,[[["writetofileserializer"],["self"]],["bool"]]],[11,"eq","","",13,[[["self"],["writetofile"]],["bool"]]],[11,"ne","","",13,[[["self"],["writetofile"]],["bool"]]],[11,"eq","","",7,[[["self"],["observermode"]],["bool"]]],[11,"ne","","",7,[[["self"],["observermode"]],["bool"]]],[11,"eq","","",4,[[["self"],["argminresult"]],["bool"]]],[11,"eq","","",8,[[["self"],["checkpointmode"]],["bool"]]],[11,"ne","","",8,[[["self"],["checkpointmode"]],["bool"]]],[11,"eq","","",18,[[["self"],["argmincheckpoint"]],["bool"]]],[11,"ne","","",18,[[["self"],["argmincheckpoint"]],["bool"]]],[11,"eq","","",9,[[["self"],["terminationreason"]],["bool"]]],[11,"eq","argmin::solver::conjugategradient::beta","",81,[[["self"],["fletcherreeves"]],["bool"]]],[11,"eq","","",82,[[["polakribiere"],["self"]],["bool"]]],[11,"eq","","",83,[[["self"],["polakribiereplus"]],["bool"]]],[11,"eq","","",84,[[["hestenesstiefel"],["self"]],["bool"]]],[11,"eq","argmin::solver::trustregion::cauchypoint","",109,[[["self"],["cauchypoint"]],["bool"]]],[11,"ne","","",109,[[["self"],["cauchypoint"]],["bool"]]],[11,"eq","argmin::solver::trustregion::dogleg","",110,[[["self"],["dogleg"]],["bool"]]],[11,"ne","","",110,[[["self"],["dogleg"]],["bool"]]],[11,"eq","argmin::solver::trustregion::steihaug","",111,[[["steihaug"],["self"]],["bool"]]],[11,"ne","","",111,[[["steihaug"],["self"]],["bool"]]],[11,"partial_cmp","argmin::core","",1,[[["argminkv"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",1,[[["argminkv"],["self"]],["bool"]]],[11,"le","","",1,[[["argminkv"],["self"]],["bool"]]],[11,"gt","","",1,[[["argminkv"],["self"]],["bool"]]],[11,"ge","","",1,[[["argminkv"],["self"]],["bool"]]],[11,"partial_cmp","","",11,[[["nooperator"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",11,[[["nooperator"],["self"]],["bool"]]],[11,"le","","",11,[[["nooperator"],["self"]],["bool"]]],[11,"gt","","",11,[[["nooperator"],["self"]],["bool"]]],[11,"ge","","",11,[[["nooperator"],["self"]],["bool"]]],[11,"partial_cmp","","",12,[[["minimalnooperator"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","","",6,[[["writetofileserializer"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","","",13,[[["self"],["writetofile"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",13,[[["self"],["writetofile"]],["bool"]]],[11,"le","","",13,[[["self"],["writetofile"]],["bool"]]],[11,"gt","","",13,[[["self"],["writetofile"]],["bool"]]],[11,"ge","","",13,[[["self"],["writetofile"]],["bool"]]],[11,"partial_cmp","","",7,[[["self"],["observermode"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",7,[[["self"],["observermode"]],["bool"]]],[11,"le","","",7,[[["self"],["observermode"]],["bool"]]],[11,"gt","","",7,[[["self"],["observermode"]],["bool"]]],[11,"ge","","",7,[[["self"],["observermode"]],["bool"]]],[11,"partial_cmp","","",4,[[["self"],["argminresult"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","","",8,[[["self"],["checkpointmode"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",8,[[["self"],["checkpointmode"]],["bool"]]],[11,"le","","",8,[[["self"],["checkpointmode"]],["bool"]]],[11,"gt","","",8,[[["self"],["checkpointmode"]],["bool"]]],[11,"ge","","",8,[[["self"],["checkpointmode"]],["bool"]]],[11,"partial_cmp","","",18,[[["self"],["argmincheckpoint"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",18,[[["self"],["argmincheckpoint"]],["bool"]]],[11,"le","","",18,[[["self"],["argmincheckpoint"]],["bool"]]],[11,"gt","","",18,[[["self"],["argmincheckpoint"]],["bool"]]],[11,"ge","","",18,[[["self"],["argmincheckpoint"]],["bool"]]],[11,"partial_cmp","","",9,[[["self"],["terminationreason"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","argmin::solver::conjugategradient::beta","",81,[[["self"],["fletcherreeves"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","","",82,[[["polakribiere"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","","",83,[[["self"],["polakribiereplus"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","","",84,[[["hestenesstiefel"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","argmin::solver::trustregion::cauchypoint","",109,[[["self"],["cauchypoint"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",109,[[["self"],["cauchypoint"]],["bool"]]],[11,"le","","",109,[[["self"],["cauchypoint"]],["bool"]]],[11,"gt","","",109,[[["self"],["cauchypoint"]],["bool"]]],[11,"ge","","",109,[[["self"],["cauchypoint"]],["bool"]]],[11,"partial_cmp","argmin::solver::trustregion::dogleg","",110,[[["self"],["dogleg"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",110,[[["self"],["dogleg"]],["bool"]]],[11,"le","","",110,[[["self"],["dogleg"]],["bool"]]],[11,"gt","","",110,[[["self"],["dogleg"]],["bool"]]],[11,"ge","","",110,[[["self"],["dogleg"]],["bool"]]],[11,"partial_cmp","argmin::solver::trustregion::steihaug","",111,[[["steihaug"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",111,[[["steihaug"],["self"]],["bool"]]],[11,"le","","",111,[[["steihaug"],["self"]],["bool"]]],[11,"gt","","",111,[[["steihaug"],["self"]],["bool"]]],[11,"ge","","",111,[[["steihaug"],["self"]],["bool"]]],[11,"fmt","argmin::core","",5,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",11,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",12,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",6,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",13,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",7,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",3,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",8,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",18,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",9,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",42,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::brent","",77,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::conjugategradient::beta","",81,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",82,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",83,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",84,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::linesearch::condition","",91,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",92,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",93,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",94,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::particleswarm","",100,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::simulatedannealing","",107,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::trustregion::cauchypoint","",109,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::trustregion::dogleg","",110,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::solver::trustregion::steihaug","",111,[[["formatter"],["self"]],["result"]]],[11,"fmt","argmin::core","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","argmin::solver::brent","",77,[[["self"],["formatter"]],["result"]]],[11,"hash","argmin::core","",1,[[["self"],["__h"]]]],[11,"hash","","",11,[[["self"],["__h"]]]],[11,"hash","","",12,[[["self"],["__h"]]]],[11,"hash","","",8,[[["self"],["__h"]]]],[11,"hash","","",18,[[["self"],["__h"]]]],[11,"hash","","",9,[[["self"],["__h"]]]],[11,"hash","argmin::solver::conjugategradient::beta","",81,[[["self"],["__h"]]]],[11,"hash","","",82,[[["self"],["__h"]]]],[11,"hash","","",83,[[["self"],["__h"]]]],[11,"hash","","",84,[[["self"],["__h"]]]],[11,"from_iter","argmin::core","",1,[[["intoiterator"]],["self"]]],[11,"serialize","argmin::core::executor","",10,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::core","",0,[[["self"],["__s"]],["result"]]],[11,"serialize","","",1,[[["self"],["__s"]],["result"]]],[11,"serialize","","",11,[[["self"],["__s"]],["result"]]],[11,"serialize","","",12,[[["self"],["__s"]],["result"]]],[11,"serialize","","",6,[[["self"],["__s"]],["result"]]],[11,"serialize","","",13,[[["self"],["__s"]],["result"]]],[11,"serialize","","",7,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"serialize","","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","","",18,[[["self"],["__s"]],["result"]]],[11,"serialize","","",9,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::brent","",78,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::conjugategradient::cg","",79,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::conjugategradient::nonlinear_cg","",80,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::conjugategradient::beta","",81,[[["self"],["__s"]],["result"]]],[11,"serialize","","",82,[[["self"],["__s"]],["result"]]],[11,"serialize","","",83,[[["self"],["__s"]],["result"]]],[11,"serialize","","",84,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::gaussnewton::gaussnewton_linesearch","",85,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::gaussnewton::gaussnewton_method","",86,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::gradientdescent::steepestdescent","",87,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::landweber","",88,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::linesearch::backtracking","",89,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::linesearch::condition","",91,[[["self"],["__s"]],["result"]]],[11,"serialize","","",92,[[["self"],["__s"]],["result"]]],[11,"serialize","","",93,[[["self"],["__s"]],["result"]]],[11,"serialize","","",94,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::linesearch::hagerzhang","",95,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::linesearch::morethuente","",96,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::neldermead","",97,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::newton::newton_cg","",98,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::newton::newton_method","",99,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::particleswarm","",101,[[["self"],["__s"]],["result"]]],[11,"serialize","","",100,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::quasinewton::bfgs","",102,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::quasinewton::dfp","",103,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::quasinewton::lbfgs","",104,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::quasinewton::sr1","",105,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::quasinewton::sr1_trustregion","",106,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::simulatedannealing","",107,[[["self"],["__s"]],["result"]]],[11,"serialize","","",108,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::trustregion::cauchypoint","",109,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::trustregion::dogleg","",110,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::trustregion::steihaug","",111,[[["self"],["__s"]],["result"]]],[11,"serialize","argmin::solver::trustregion::trustregion_method","",112,[[["self"],["__s"]],["result"]]],[11,"deserialize","argmin::core::executor","",10,[[["__d"]],["result"]]],[11,"deserialize","argmin::core","",0,[[["__d"]],["result"]]],[11,"deserialize","","",1,[[["__d"]],["result"]]],[11,"deserialize","","",11,[[["__d"]],["result"]]],[11,"deserialize","","",12,[[["__d"]],["result"]]],[11,"deserialize","","",6,[[["__d"]],["result"]]],[11,"deserialize","","",13,[[["__d"]],["result"]]],[11,"deserialize","","",7,[[["__d"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result"]]],[11,"deserialize","","",8,[[["__d"]],["result"]]],[11,"deserialize","","",18,[[["__d"]],["result"]]],[11,"deserialize","","",9,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::brent","",78,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::conjugategradient::cg","",79,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::conjugategradient::nonlinear_cg","",80,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::conjugategradient::beta","",81,[[["__d"]],["result"]]],[11,"deserialize","","",82,[[["__d"]],["result"]]],[11,"deserialize","","",83,[[["__d"]],["result"]]],[11,"deserialize","","",84,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::gaussnewton::gaussnewton_linesearch","",85,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::gaussnewton::gaussnewton_method","",86,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::gradientdescent::steepestdescent","",87,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::landweber","",88,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::linesearch::backtracking","",89,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::linesearch::condition","",91,[[["__d"]],["result"]]],[11,"deserialize","","",92,[[["__d"]],["result"]]],[11,"deserialize","","",93,[[["__d"]],["result"]]],[11,"deserialize","","",94,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::linesearch::hagerzhang","",95,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::linesearch::morethuente","",96,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::neldermead","",97,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::newton::newton_cg","",98,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::newton::newton_method","",99,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::particleswarm","",101,[[["__d"]],["result"]]],[11,"deserialize","","",100,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::quasinewton::bfgs","",102,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::quasinewton::dfp","",103,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::quasinewton::lbfgs","",104,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::quasinewton::sr1","",105,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::quasinewton::sr1_trustregion","",106,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::simulatedannealing","",107,[[["__d"]],["result"]]],[11,"deserialize","","",108,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::trustregion::cauchypoint","",109,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::trustregion::dogleg","",110,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::trustregion::steihaug","",111,[[["__d"]],["result"]]],[11,"deserialize","argmin::solver::trustregion::trustregion_method","",112,[[["__d"]],["result"]]],[11,"serialize","argmin::core","",2,[[["record"],["self"],["serializer"]],["result"]]],[11,"serialize","","",0,[[["record"],["self"],["serializer"]],["result"]]],[11,"new","","Create a new error object from any error type.",113,[[["e"]],["error"]]],[11,"msg","","Create a new error object from a printable error message.",113,[[["m"]],["error"]]],[11,"context","","Wrap the error value with additional context.",113,[[["c"]],["error"]]],[11,"chain","","An iterator of the chain of source errors contained by…",113,[[["self"]],["chain"]]],[11,"root_cause","","The lowest level cause of this error — this error's…",113,[[["self"]],["error"]]],[11,"is","","Returns true if `E` is the type held by this error object.",113,[[["self"]],["bool"]]],[11,"downcast","","Attempt to downcast the error object to a concrete type.",113,[[],[["result",["error"]],["error"]]]],[11,"downcast_ref","","Downcast this error object by reference.",113,[[["self"]],[["option"],["e"]]]],[11,"downcast_mut","","Downcast this error object by mutable reference.",113,[[["self"]],[["option"],["e"]]]],[11,"observe_init","","Called once at the beginning of the execution of the solver.",36,[[["str"],["argminkv"],["self"]],[["result",["error"]],["error"]]]],[11,"observe_iter","","Called at every iteration of the solver",36,[[["self"],["iterstate"],["argminkv"]],[["result",["error"]],["error"]]]]],"p":[[3,"IterState"],[3,"ArgminKV"],[3,"ArgminSlogKV"],[3,"OpWrapper"],[3,"ArgminResult"],[4,"ArgminError"],[4,"WriteToFileSerializer"],[4,"ObserverMode"],[4,"CheckpointMode"],[4,"TerminationReason"],[3,"Executor"],[3,"NoOperator"],[3,"MinimalNoOperator"],[3,"WriteToFile"],[3,"ArgminSlogLogger"],[3,"Visualizer3d"],[3,"Surface"],[3,"Observer"],[3,"ArgminCheckpoint"],[8,"ArgminDot"],[8,"ArgminWeightedDot"],[8,"ArgminZero"],[8,"ArgminConj"],[8,"ArgminZeroLike"],[8,"ArgminEye"],[8,"ArgminAdd"],[8,"ArgminSub"],[8,"ArgminMul"],[8,"ArgminDiv"],[8,"ArgminScaledAdd"],[8,"ArgminScaledSub"],[8,"ArgminNorm"],[8,"ArgminTranspose"],[8,"ArgminInv"],[8,"ArgminRandom"],[8,"ArgminMinMax"],[8,"Observe"],[8,"ArgminOp"],[8,"Solver"],[8,"ArgminLineSearch"],[8,"ArgminTrustRegion"],[8,"ArgminNLCGBetaUpdate"],[3,"ArgminIterData"],[8,"Bounded"],[8,"ToPrimitive"],[8,"FromPrimitive"],[8,"NumCast"],[8,"AsPrimitive"],[8,"FloatCore"],[8,"Float"],[8,"FloatConst"],[8,"Zero"],[8,"One"],[8,"PrimInt"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"CheckedRem"],[8,"CheckedNeg"],[8,"CheckedShl"],[8,"CheckedShr"],[8,"Inv"],[8,"MulAdd"],[8,"MulAddAssign"],[8,"Saturating"],[8,"WrappingAdd"],[8,"WrappingSub"],[8,"WrappingMul"],[8,"WrappingShl"],[8,"WrappingShr"],[8,"Pow"],[8,"Real"],[8,"Signed"],[8,"Num"],[4,"FloatErrorKind"],[3,"ParseFloatError"],[4,"BrentError"],[3,"Brent"],[3,"ConjugateGradient"],[3,"NonlinearConjugateGradient"],[3,"FletcherReeves"],[3,"PolakRibiere"],[3,"PolakRibierePlus"],[3,"HestenesStiefel"],[3,"GaussNewtonLS"],[3,"GaussNewton"],[3,"SteepestDescent"],[3,"Landweber"],[3,"BacktrackingLineSearch"],[8,"LineSearchCondition"],[3,"ArmijoCondition"],[3,"WolfeCondition"],[3,"StrongWolfeCondition"],[3,"GoldsteinCondition"],[3,"HagerZhangLineSearch"],[3,"MoreThuenteLineSearch"],[3,"NelderMead"],[3,"NewtonCG"],[3,"Newton"],[3,"Particle"],[3,"ParticleSwarm"],[3,"BFGS"],[3,"DFP"],[3,"LBFGS"],[3,"SR1"],[3,"SR1TrustRegion"],[4,"SATempFunc"],[3,"SimulatedAnnealing"],[3,"CauchyPoint"],[3,"Dogleg"],[3,"Steihaug"],[3,"TrustRegion"],[3,"Error"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);